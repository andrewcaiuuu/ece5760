[{"id":0,"href":"/docs/","title":"Docs","section":"Home","content":""},{"id":1,"href":"/docs/code/","title":"Home","section":"Docs","content":"\rFPGA Accelerated Thread Art\r#\rProject Introduction\r#\rWe create a parallel implementation of \u0026ldquo;thread art\u0026rdquo; algorithm that simulates rendering an image by wrapping single piece of string around hooks placed in a circle.\nExample Excution Progress 20% 40% 60% 80% 100% ref High Level Design\r#\rWe utilize a simplified version of the algorithm from this github repository.\nThere are many similar implementations, but we found that the optimizations introduced here resulted in better quality images.\nAt a high level, all the different algorithms aim to try possible lines from a given starting hook, and pick the resulting line that results in greatest similarity to the original image.\nIn order to compute similarity, a penalty is formally defined below as:\nFor ease of computation, images are first inverted, with 255 representing complete darkness, and 0 representing complete brightness.\nA paramterized value Line Darkness set as 150 by default represents the darkness of a line. If a line is drawn through a sets of points, all points in the set have their inverted pixel value subtracted by 150.\npi represents the inverted pixel value.\nwi represents the corresponding weight value, which applies a multiplier between 0 and 1, allowing for some pixels to contribute more to overall penalty and therefore be prioritized.\nL represents the lightness penalty, another value between 0 and 1 that allows for negative values to contribute less to overall penalty, therefore increasing the algorithms willingness to draw more lines.\nAt each step, the algorithm computes possible lines from a starting point and calculates the penalty through those points with (pixel values subtracted by Line Darkness) and without (original pixel values). It then selects the line the reduces the penalty by the greatest amount.\nFrom there, the chosen point because the starting point at the next step.\nThe most important additions here are pixel weightings and parameterized lightness penalty. This allows for more detailed images.\nvar panel = ram_design; if (backup + system) { file.readPoint = network_native; sidebar_engine_device(cell_tftp_raster, dual_login_paper.adf_vci.application_reader_design( graphicsNvramCdma, lpi_footer_snmp, integer_model)); } Locis suis novi cum suoque decidit eadem\r#\rIdmoniae ripis, at aves, ali missa adest, ut et autem, et ab?\n"},{"id":2,"href":"/docs/gallery/gallery/","title":"Home","section":"Docs","content":"\rFPGA Accelerated Thread Art\r#\rProject Introduction\r#\rWe create a parallel implementation of \u0026ldquo;thread art\u0026rdquo; algorithm that simulates rendering an image by wrapping single piece of string around hooks placed in a circle.\nExample Excution Progress 20% 40% 60% 80% 100% ref High Level Design\r#\rWe utilize a simplified version of the algorithm from this github repository.\nThere are many similar implementations, but we found that the optimizations introduced here resulted in better quality images.\nAt a high level, all the different algorithms aim to try possible lines from a given starting hook, and pick the resulting line that results in greatest similarity to the original image.\nIn order to compute similarity, a penalty is formally defined below as:\nFor ease of computation, images are first inverted, with 255 representing complete darkness, and 0 representing complete brightness.\nA paramterized value Line Darkness set as 150 by default represents the darkness of a line. If a line is drawn through a sets of points, all points in the set have their inverted pixel value subtracted by 150.\npi represents the inverted pixel value.\nwi represents the corresponding weight value, which applies a multiplier between 0 and 1, allowing for some pixels to contribute more to overall penalty and therefore be prioritized.\nL represents the lightness penalty, another value between 0 and 1 that allows for negative values to contribute less to overall penalty, therefore increasing the algorithms willingness to draw more lines.\nAt each step, the algorithm computes possible lines from a starting point and calculates the penalty through those points with (pixel values subtracted by Line Darkness) and without (original pixel values). It then selects the line the reduces the penalty by the greatest amount.\nFrom there, the chosen point because the starting point at the next step.\nThe most important additions here are pixel weightings and parameterized lightness penalty. This allows for more detailed images.\nvar panel = ram_design; if (backup + system) { file.readPoint = network_native; sidebar_engine_device(cell_tftp_raster, dual_login_paper.adf_vci.application_reader_design( graphicsNvramCdma, lpi_footer_snmp, integer_model)); } Locis suis novi cum suoque decidit eadem\r#\rIdmoniae ripis, at aves, ali missa adest, ut et autem, et ab?\n"}]