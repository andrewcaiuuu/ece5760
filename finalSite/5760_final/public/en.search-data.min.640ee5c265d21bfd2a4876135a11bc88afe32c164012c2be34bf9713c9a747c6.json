[{"id":0,"href":"/docs/appendix/commented-code/","title":"Commented Code","section":"Appendix","content":""},{"id":1,"href":"/docs/appendix/","title":"Appendix","section":"Docs","content":""},{"id":2,"href":"/docs/appendix/commented-code/c-implementation/","title":"C Implementation","section":"Commented Code","content":"\rC implementation\r#\r1// compile with gcc thread_art.c -o out -O2 -lm -std=c99 2#include \u0026lt;stdio.h\u0026gt; 3#include \u0026lt;stdlib.h\u0026gt; 4#include \u0026lt;math.h\u0026gt; 5#include \u0026lt;time.h\u0026gt; 6 7#define WHEEL_PIXEL_SIZE 1600 8#define N_HOOKS 160 // needs to be divisible by 2 9#define HOOK_PIXEL_SIZE 3 10#define ROWS 1600 11#define COLS 1600 12#define N_LINES 800 13#define LIGHTNESS_PENALTY 1 // defined in terms of right shifts 14#define DARKNESS 800 15#define TIME_SAVER 40 // defined as terms to actually consider 16#ifndef M_PI 17#define M_PI 3.14159265358979323846 18#endif 19#ifndef INT_MIN 20#define INT_MIN -2147483648 21#endif 22 23// HELPER STUFF 24struct Tuple 25{ 26 int x; 27 int y; 28}; 29 30struct Node 31{ 32 struct Tuple data; 33 struct Node *next; 34}; 35 36struct LinkedList 37{ 38 struct Node *head; 39 struct Node *tail; 40}; 41 42struct LinkedList *initLinkedList() 43{ 44 struct LinkedList *list = (struct LinkedList *)malloc(sizeof(struct LinkedList)); 45 list-\u0026gt;head = NULL; 46 list-\u0026gt;tail = NULL; 47 return list; 48} 49 50void freeList(struct LinkedList *list) 51{ 52 struct Node *current = list-\u0026gt;head; 53 while (current != NULL) 54 { 55 struct Node *temp = current; 56 current = current-\u0026gt;next; 57 free(temp); 58 } 59 free(list); 60} 61 62void append(struct LinkedList *list, struct Tuple data) 63{ 64 // allocate memory for the new node 65 struct Node *new_node = (struct Node *)malloc(sizeof(struct Node)); 66 67 // set the data of the new node 68 new_node-\u0026gt;data = data; 69 70 // set the next pointer of the new node to NULL 71 new_node-\u0026gt;next = NULL; 72 73 // if the list is empty, set the new node as the head and tail of the list 74 if (list-\u0026gt;head == NULL) 75 { 76 list-\u0026gt;head = new_node; 77 list-\u0026gt;tail = new_node; 78 } 79 // otherwise, append the new node to the tail of the list 80 else 81 { 82 list-\u0026gt;tail-\u0026gt;next = new_node; 83 list-\u0026gt;tail = new_node; 84 } 85} 86 87void print_list(struct LinkedList *list) 88{ 89 struct Node *current = list-\u0026gt;head; 90 int idx = 0; 91 while (current != NULL) 92 { 93 printf(\u0026#34;idx %d: (%d, %d)\\n\u0026#34;, idx, current-\u0026gt;data.x, current-\u0026gt;data.y); 94 idx++; 95 current = current-\u0026gt;next; 96 } 97} 98 99// END HELPER STUFF 100 101void read_array(int *array, char *path) 102{ 103 // open the input file 104 FILE *fp = fopen(path, \u0026#34;r\u0026#34;); 105 if (fp == NULL) 106 { 107 printf(\u0026#34;Failed to open file \\n\u0026#34;); 108 } 109 int count = 0; 110 // read the integers from the file into the array 111 for (int i = 0; i \u0026lt; ROWS; i++) 112 { 113 for (int j = 0; j \u0026lt; COLS; j++) 114 { 115 int cur; 116 if (!fscanf(fp, \u0026#34;%d\u0026#34;, \u0026amp;cur)) 117 { 118 printf(\u0026#34;FAIL\u0026#34;); 119 } 120 count++; 121 array[i * COLS + j] = cur; 122 } 123 } 124 125 // close the input file 126 fclose(fp); 127 printf(\u0026#34;count: %d\\n\u0026#34;, count); 128} 129 130void generate_hooks_with_size(struct Tuple *xy) // generates points along a circle 131{ 132 double r = (WHEEL_PIXEL_SIZE / 2.0) - 1.0; 133 double *theta = (double *)malloc((N_HOOKS) * sizeof(double)); 134 double epsilon = asin(HOOK_PIXEL_SIZE / WHEEL_PIXEL_SIZE); 135 for (int i = 0; i \u0026lt; (N_HOOKS \u0026gt;\u0026gt; 1); i++) 136 { 137 double angle = (double)i / (double)(N_HOOKS \u0026gt;\u0026gt; 1) * (2.0 * M_PI); 138 theta[i * 2] = angle - epsilon; 139 theta[i * 2 + 1] = angle + epsilon; 140 } 141 for (int j = 0; j \u0026lt; N_HOOKS; j++) 142 { 143 struct Tuple point; 144 point.x = r * (1.0 + cos(theta[j])) + 0.5; 145 point.y = r * (1.0 + sin(theta[j])) + 0.5; 146 xy[j] = point; 147 } 148 free(theta); 149} 150 151void through_pixels(struct Tuple p0, struct Tuple p1, struct LinkedList *pixels) 152{ 153 int x0 = p0.x; 154 int y0 = p0.y; 155 int x1 = p1.x; 156 int y1 = p1.y; 157 int dx = abs(x1 - x0); 158 int dy = abs(y1 - y0); 159 160 int sx = (x0 \u0026lt; x1) ? 1 : -1; 161 int sy = (y0 \u0026lt; y1) ? 1 : -1; 162 163 int err = dx - dy; 164 165 while (1) 166 { 167 struct Tuple point; 168 point.x = x0; 169 point.y = y0; 170 append(pixels, point); 171 172 if (x0 == x1 \u0026amp;\u0026amp; y0 == y1) 173 { 174 return; 175 } 176 177 int e2 = 2 * err; 178 179 if (e2 \u0026gt; -dy) 180 { 181 err -= dy; 182 x0 += sx; 183 } 184 185 if (e2 \u0026lt; dx) 186 { 187 err += dx; 188 y0 += sy; 189 } 190 else if (e2 == dx) 191 { // Handle cases with slope 1 or -1 192 err -= dy; 193 x0 += sx; 194 err += dx; 195 y0 += sy; 196 } 197 } 198} 199 200// takes image assuming it has been preprocessed for weights 201int calculate_penalty(int cur, int weight) 202{ 203 if (cur \u0026lt; 0) 204 { 205 // // DEBUG______________________________ 206 // return (weight \u0026lt; 0) ? 0 : ((int)(-cur * 0.25) \u0026gt;\u0026gt; weight); 207 // // DEBUG______________________________ 208 return (weight \u0026lt; 0) ? 0 : -((cur \u0026gt;\u0026gt; LIGHTNESS_PENALTY) \u0026gt;\u0026gt; weight); 209 } 210 else 211 { 212 return (weight \u0026lt; 0) ? 0 : (cur \u0026gt;\u0026gt; weight); 213 } 214} 215 216void generate_unique_random_numbers(int min, int max, int exclude, int N, int *result) 217{ 218 int range = max - min + 1; 219 int adjusted_range = range - (exclude \u0026gt;= min \u0026amp;\u0026amp; exclude \u0026lt;= max); 220 if (N \u0026gt; adjusted_range) 221 { 222 printf(\u0026#34;Error: Cannot generate %d unique random numbers in the given range.\\n\u0026#34;, N); 223 return; 224 } 225 226 int *flags = (int *)calloc(range, sizeof(int)); 227 flags[exclude - min] = 1; 228 229 for (int i = 0; i \u0026lt; N; i++) 230 { 231 int rand_num; 232 do 233 { 234 rand_num = rand() % range + min; 235 } while (flags[rand_num - min]); 236 237 flags[rand_num - min] = 1; 238 result[i] = rand_num; 239 } 240 241 free(flags); 242} 243 244void optimise_fitness(int *image, int *weight, int *previous_edge, struct Tuple *xy) 245{ 246 int starting_edge = *previous_edge; 247 int count = 0; 248 // randomly chose a subset of endpoints 249 int *chosen = (int *)malloc(TIME_SAVER * sizeof(int)); 250 generate_unique_random_numbers(0, N_HOOKS - 1, starting_edge, TIME_SAVER, chosen); 251 252 // // DEBUG______________________________ 253 // for (int ii = 0; ii \u0026lt; TIME_SAVER; ii ++){ 254 // printf(\u0026#34;el %d: %d \\n\u0026#34;, ii, chosen[ii]); 255 // } 256 // // DEBUG______________________________ 257 258 int best_endpoint = -1; 259 int best_reduction = INT_MIN; 260 for (int i = 0; i \u0026lt; TIME_SAVER; i++) 261 { 262 int ending_edge = chosen[i]; 263 struct LinkedList *pixels = initLinkedList(); 264 int penalty_without = 0; 265 int penalty_with = 0; 266 int reduction; 267 through_pixels(xy[starting_edge], xy[ending_edge], pixels); 268 int norm = 0; 269 struct Node *current = pixels-\u0026gt;head; 270 while (current != NULL) 271 { 272 norm++; 273 struct Node *temp = current; 274 int image_data = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; 275 int weight_data; 276 if (temp-\u0026gt;data.y % 2 == 0) { 277 weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; 278 } 279 else { 280 weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y - 1) * COLS]; 281 } 282 283 int cur_penalty_without = calculate_penalty(image_data, weight_data); 284 int cur_penalty_with = calculate_penalty(image_data - DARKNESS, weight_data); 285 penalty_with = cur_penalty_with + penalty_with; 286 penalty_without = cur_penalty_without + penalty_without; 287 current = current-\u0026gt;next; 288 free(temp); 289 } 290 free(pixels); 291 reduction = (penalty_without - penalty_with) / norm; 292 if (reduction \u0026gt; best_reduction) 293 { 294 best_reduction = reduction; 295 best_endpoint = ending_edge; 296 } 297 } 298 free(chosen); 299 *previous_edge = best_endpoint; 300} 301 302void update_image(int *image, struct Tuple *xy, int start, int end) 303{ 304 struct LinkedList *pixels = initLinkedList(); 305 through_pixels(xy[start], xy[end], pixels); 306 struct Node *current = pixels-\u0026gt;head; 307 while (current != NULL) 308 { 309 struct Node *temp = current; 310 image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] - DARKNESS; 311 current = current-\u0026gt;next; 312 free(temp); 313 } 314 free(pixels); 315} 316 317void find_lines(int *image, int *weight, struct Tuple *xy, struct Tuple *line_list) 318{ 319 int next_edge_value = rand() % N_HOOKS; 320 int *next_edge = \u0026amp;next_edge_value; 321 for (int i = 0; i \u0026lt; N_LINES; i++) 322 { 323 int previous_edge = *next_edge; 324 optimise_fitness(image, weight, next_edge, xy); 325 update_image(image, xy, previous_edge, *next_edge); 326 line_list[i * 2] = xy[previous_edge]; 327 line_list[i * 2 + 1] = xy[*next_edge]; 328 } 329} 330 331void p_t(struct Tuple point) 332{ 333 printf(\u0026#34;%d, %d\u0026#34;, point.x, point.y); 334} 335 336int main() 337{ 338 // static seed for testing 339 srand(42); 340 341 clock_t start, end; 342 double cpu_time_used; 343 start = clock(); 344 printf(\u0026#34;Generating Hooks\\n\u0026#34;); 345 346 struct Tuple *xy = (struct Tuple *)malloc(N_HOOKS * sizeof(struct Tuple)); 347 348 generate_hooks_with_size(xy); 349 350 printf(\u0026#34;Reading Image Data\\n\u0026#34;); 351 int *ah_monochrome = malloc((ROWS * COLS) * sizeof(int)); 352 read_array(ah_monochrome, \u0026#34;monalisa.txt\u0026#34;); 353 354 printf(\u0026#34;Reading Weight Data\\n\u0026#34;); 355 int *ah_weights = malloc((ROWS * COLS) * sizeof(int)); 356 read_array(ah_weights, \u0026#34;ah_wpos.txt\u0026#34;); 357 358 // COMMENT WHEN USING WEIGHTS 359 // for (int j = 0; j \u0026lt; ROWS; j++){ 360 // for (int k = 0; k \u0026lt; COLS; k++){ 361 // ah_weights[j*COLS+k] = 0; 362 // } 363 // } 364 365 printf(\u0026#34;Allocating connections list and running optimizer\\n\u0026#34;); 366 struct Tuple *line_list = (struct Tuple *)malloc(N_LINES * sizeof(struct Tuple) * 2); 367 find_lines(ah_monochrome, ah_weights, xy, line_list); 368 369 // Open the file for writing 370 printf(\u0026#34;Done, writing output file\\n\u0026#34;); 371 FILE *file = fopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;); 372 if (file == NULL) 373 { 374 printf(\u0026#34;Error opening the file.\\n\u0026#34;); 375 return 1; 376 } 377 378 // Write the array elements to the file 379 for (int i = 0; i \u0026lt; N_LINES; i++) 380 { 381 fprintf(file, \u0026#34;%d\u0026#34;, line_list[i * 2].x); 382 fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2].y); 383 fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].x); 384 fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].y); 385 // Use a newline character instead of a comma to separate elements 386 if (i \u0026lt; N_LINES - 1) 387 { 388 fprintf(file, \u0026#34;\\n\u0026#34;); 389 } 390 } 391 392 // Close the file 393 fclose(file); 394 395 printf(\u0026#34;Array written to the output.txt file.\\n\u0026#34;); 396 397 free(line_list); 398 free(xy); 399 free(ah_monochrome); 400 free(ah_weights); 401 402 end = clock(); 403 cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC; 404 405 printf(\u0026#34;Memory freed, used %f CPU time\\n\u0026#34;, cpu_time_used); 406 return 0; 407} "},{"id":3,"href":"/docs/appendix/gallery/","title":"Gallery","section":"Appendix","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":4,"href":"/docs/","title":"Docs","section":"Home","content":""}]