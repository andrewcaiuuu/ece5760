[{"id":0,"href":"/docs/appendix/commented-code/","title":"Commented Code","section":"Appendix","content":""},{"id":1,"href":"/docs/appendix/commented-code/verilog-implementation/","title":"Verilog Implementation","section":"Commented Code","content":""},{"id":2,"href":"/docs/appendix/","title":"Appendix","section":"Docs","content":""},{"id":3,"href":"/docs/appendix/commented-code/c-implementation/","title":"C Implementation","section":"Commented Code","content":"\rC implementation\r#\r// compile with gcc thread_art.c -o out -O2 -lm -std=c99 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define WHEEL_PIXEL_SIZE 1600 #define N_HOOKS 160 // needs to be divisible by 2 #define HOOK_PIXEL_SIZE 3 #define ROWS 1600 #define COLS 1600 #define N_LINES 800 #define LIGHTNESS_PENALTY 1 // defined in terms of right shifts #define DARKNESS 800 #define TIME_SAVER 40 // defined as terms to actually consider #ifndef M_PI #define M_PI 3.14159265358979323846 #endif #ifndef INT_MIN #define INT_MIN -2147483648 #endif // HELPER STUFF struct Tuple { int x; int y; }; struct Node { struct Tuple data; struct Node *next; }; struct LinkedList { struct Node *head; struct Node *tail; }; struct LinkedList *initLinkedList() { struct LinkedList *list = (struct LinkedList *)malloc(sizeof(struct LinkedList)); list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; return list; } void freeList(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; while (current != NULL) { struct Node *temp = current; current = current-\u0026gt;next; free(temp); } free(list); } void append(struct LinkedList *list, struct Tuple data) { // allocate memory for the new node struct Node *new_node = (struct Node *)malloc(sizeof(struct Node)); // set the data of the new node new_node-\u0026gt;data = data; // set the next pointer of the new node to NULL new_node-\u0026gt;next = NULL; // if the list is empty, set the new node as the head and tail of the list if (list-\u0026gt;head == NULL) { list-\u0026gt;head = new_node; list-\u0026gt;tail = new_node; } // otherwise, append the new node to the tail of the list else { list-\u0026gt;tail-\u0026gt;next = new_node; list-\u0026gt;tail = new_node; } } void print_list(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; int idx = 0; while (current != NULL) { printf(\u0026#34;idx %d: (%d, %d)\\n\u0026#34;, idx, current-\u0026gt;data.x, current-\u0026gt;data.y); idx++; current = current-\u0026gt;next; } } // END HELPER STUFF void read_array(int *array, char *path) { // open the input file FILE *fp = fopen(path, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;Failed to open file \\n\u0026#34;); } int count = 0; // read the integers from the file into the array for (int i = 0; i \u0026lt; ROWS; i++) { for (int j = 0; j \u0026lt; COLS; j++) { int cur; if (!fscanf(fp, \u0026#34;%d\u0026#34;, \u0026amp;cur)) { printf(\u0026#34;FAIL\u0026#34;); } count++; array[i * COLS + j] = cur; } } // close the input file fclose(fp); printf(\u0026#34;count: %d\\n\u0026#34;, count); } void generate_hooks_with_size(struct Tuple *xy) // generates points along a circle { double r = (WHEEL_PIXEL_SIZE / 2.0) - 1.0; double *theta = (double *)malloc((N_HOOKS) * sizeof(double)); double epsilon = asin(HOOK_PIXEL_SIZE / WHEEL_PIXEL_SIZE); for (int i = 0; i \u0026lt; (N_HOOKS \u0026gt;\u0026gt; 1); i++) { double angle = (double)i / (double)(N_HOOKS \u0026gt;\u0026gt; 1) * (2.0 * M_PI); theta[i * 2] = angle - epsilon; theta[i * 2 + 1] = angle + epsilon; } for (int j = 0; j \u0026lt; N_HOOKS; j++) { struct Tuple point; point.x = r * (1.0 + cos(theta[j])) + 0.5; point.y = r * (1.0 + sin(theta[j])) + 0.5; xy[j] = point; } free(theta); } void through_pixels(struct Tuple p0, struct Tuple p1, struct LinkedList *pixels) { int x0 = p0.x; int y0 = p0.y; int x1 = p1.x; int y1 = p1.y; int dx = abs(x1 - x0); int dy = abs(y1 - y0); int sx = (x0 \u0026lt; x1) ? 1 : -1; int sy = (y0 \u0026lt; y1) ? 1 : -1; int err = dx - dy; while (1) { struct Tuple point; point.x = x0; point.y = y0; append(pixels, point); if (x0 == x1 \u0026amp;\u0026amp; y0 == y1) { return; } int e2 = 2 * err; if (e2 \u0026gt; -dy) { err -= dy; x0 += sx; } if (e2 \u0026lt; dx) { err += dx; y0 += sy; } else if (e2 == dx) { // Handle cases with slope 1 or -1 err -= dy; x0 += sx; err += dx; y0 += sy; } } } // takes image assuming it has been preprocessed for weights int calculate_penalty(int cur, int weight) { if (cur \u0026lt; 0) { // // DEBUG______________________________ // return (weight \u0026lt; 0) ? 0 : ((int)(-cur * 0.25) \u0026gt;\u0026gt; weight); // // DEBUG______________________________ return (weight \u0026lt; 0) ? 0 : -((cur \u0026gt;\u0026gt; LIGHTNESS_PENALTY) \u0026gt;\u0026gt; weight); } else { return (weight \u0026lt; 0) ? 0 : (cur \u0026gt;\u0026gt; weight); } } void generate_unique_random_numbers(int min, int max, int exclude, int N, int *result) { int range = max - min + 1; int adjusted_range = range - (exclude \u0026gt;= min \u0026amp;\u0026amp; exclude \u0026lt;= max); if (N \u0026gt; adjusted_range) { printf(\u0026#34;Error: Cannot generate %d unique random numbers in the given range.\\n\u0026#34;, N); return; } int *flags = (int *)calloc(range, sizeof(int)); flags[exclude - min] = 1; for (int i = 0; i \u0026lt; N; i++) { int rand_num; do { rand_num = rand() % range + min; } while (flags[rand_num - min]); flags[rand_num - min] = 1; result[i] = rand_num; } free(flags); } void optimise_fitness(int *image, int *weight, int *previous_edge, struct Tuple *xy) { int starting_edge = *previous_edge; int count = 0; // randomly chose a subset of endpoints int *chosen = (int *)malloc(TIME_SAVER * sizeof(int)); generate_unique_random_numbers(0, N_HOOKS - 1, starting_edge, TIME_SAVER, chosen); // // DEBUG______________________________ // for (int ii = 0; ii \u0026lt; TIME_SAVER; ii ++){ // printf(\u0026#34;el %d: %d \\n\u0026#34;, ii, chosen[ii]); // } // // DEBUG______________________________ int best_endpoint = -1; int best_reduction = INT_MIN; for (int i = 0; i \u0026lt; TIME_SAVER; i++) { int ending_edge = chosen[i]; struct LinkedList *pixels = initLinkedList(); int penalty_without = 0; int penalty_with = 0; int reduction; through_pixels(xy[starting_edge], xy[ending_edge], pixels); int norm = 0; struct Node *current = pixels-\u0026gt;head; while (current != NULL) { norm++; struct Node *temp = current; int image_data = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; int weight_data; if (temp-\u0026gt;data.y % 2 == 0) { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; } else { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y - 1) * COLS]; } int cur_penalty_without = calculate_penalty(image_data, weight_data); int cur_penalty_with = calculate_penalty(image_data - DARKNESS, weight_data); penalty_with = cur_penalty_with + penalty_with; penalty_without = cur_penalty_without + penalty_without; current = current-\u0026gt;next; free(temp); } free(pixels); reduction = (penalty_without - penalty_with) / norm; if (reduction \u0026gt; best_reduction) { best_reduction = reduction; best_endpoint = ending_edge; } } free(chosen); *previous_edge = best_endpoint; } void update_image(int *image, struct Tuple *xy, int start, int end) { struct LinkedList *pixels = initLinkedList(); through_pixels(xy[start], xy[end], pixels); struct Node *current = pixels-\u0026gt;head; while (current != NULL) { struct Node *temp = current; image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] - DARKNESS; current = current-\u0026gt;next; free(temp); } free(pixels); } void find_lines(int *image, int *weight, struct Tuple *xy, struct Tuple *line_list) { int next_edge_value = rand() % N_HOOKS; int *next_edge = \u0026amp;next_edge_value; for (int i = 0; i \u0026lt; N_LINES; i++) { int previous_edge = *next_edge; optimise_fitness(image, weight, next_edge, xy); update_image(image, xy, previous_edge, *next_edge); line_list[i * 2] = xy[previous_edge]; line_list[i * 2 + 1] = xy[*next_edge]; } } void p_t(struct Tuple point) { printf(\u0026#34;%d, %d\u0026#34;, point.x, point.y); } int main() { // static seed for testing srand(42); clock_t start, end; double cpu_time_used; start = clock(); printf(\u0026#34;Generating Hooks\\n\u0026#34;); struct Tuple *xy = (struct Tuple *)malloc(N_HOOKS * sizeof(struct Tuple)); generate_hooks_with_size(xy); printf(\u0026#34;Reading Image Data\\n\u0026#34;); int *ah_monochrome = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_monochrome, \u0026#34;monalisa.txt\u0026#34;); printf(\u0026#34;Reading Weight Data\\n\u0026#34;); int *ah_weights = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_weights, \u0026#34;ah_wpos.txt\u0026#34;); // COMMENT WHEN USING WEIGHTS // for (int j = 0; j \u0026lt; ROWS; j++){ // for (int k = 0; k \u0026lt; COLS; k++){ // ah_weights[j*COLS+k] = 0; // } // } printf(\u0026#34;Allocating connections list and running optimizer\\n\u0026#34;); struct Tuple *line_list = (struct Tuple *)malloc(N_LINES * sizeof(struct Tuple) * 2); find_lines(ah_monochrome, ah_weights, xy, line_list); // Open the file for writing printf(\u0026#34;Done, writing output file\\n\u0026#34;); FILE *file = fopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening the file.\\n\u0026#34;); return 1; } // Write the array elements to the file for (int i = 0; i \u0026lt; N_LINES; i++) { fprintf(file, \u0026#34;%d\u0026#34;, line_list[i * 2].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2].y); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].y); // Use a newline character instead of a comma to separate elements if (i \u0026lt; N_LINES - 1) { fprintf(file, \u0026#34;\\n\u0026#34;); } } // Close the file fclose(file); printf(\u0026#34;Array written to the output.txt file.\\n\u0026#34;); free(line_list); free(xy); free(ah_monochrome); free(ah_weights); end = clock(); cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC; printf(\u0026#34;Memory freed, used %f CPU time\\n\u0026#34;, cpu_time_used); return 0; } "},{"id":4,"href":"/docs/appendix/commented-code/verilog-implementation/top-level/","title":"Top Level","section":"Verilog Implementation","content":"\rC implementation\r#\r// compile with gcc thread_art.c -o out -O2 -lm -std=c99 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define WHEEL_PIXEL_SIZE 1600 #define N_HOOKS 160 // needs to be divisible by 2 #define HOOK_PIXEL_SIZE 3 #define ROWS 1600 #define COLS 1600 #define N_LINES 800 #define LIGHTNESS_PENALTY 1 // defined in terms of right shifts #define DARKNESS 800 #define TIME_SAVER 40 // defined as terms to actually consider #ifndef M_PI #define M_PI 3.14159265358979323846 #endif #ifndef INT_MIN #define INT_MIN -2147483648 #endif // HELPER STUFF struct Tuple { int x; int y; }; struct Node { struct Tuple data; struct Node *next; }; struct LinkedList { struct Node *head; struct Node *tail; }; struct LinkedList *initLinkedList() { struct LinkedList *list = (struct LinkedList *)malloc(sizeof(struct LinkedList)); list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; return list; } void freeList(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; while (current != NULL) { struct Node *temp = current; current = current-\u0026gt;next; free(temp); } free(list); } void append(struct LinkedList *list, struct Tuple data) { // allocate memory for the new node struct Node *new_node = (struct Node *)malloc(sizeof(struct Node)); // set the data of the new node new_node-\u0026gt;data = data; // set the next pointer of the new node to NULL new_node-\u0026gt;next = NULL; // if the list is empty, set the new node as the head and tail of the list if (list-\u0026gt;head == NULL) { list-\u0026gt;head = new_node; list-\u0026gt;tail = new_node; } // otherwise, append the new node to the tail of the list else { list-\u0026gt;tail-\u0026gt;next = new_node; list-\u0026gt;tail = new_node; } } void print_list(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; int idx = 0; while (current != NULL) { printf(\u0026#34;idx %d: (%d, %d)\\n\u0026#34;, idx, current-\u0026gt;data.x, current-\u0026gt;data.y); idx++; current = current-\u0026gt;next; } } // END HELPER STUFF void read_array(int *array, char *path) { // open the input file FILE *fp = fopen(path, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;Failed to open file \\n\u0026#34;); } int count = 0; // read the integers from the file into the array for (int i = 0; i \u0026lt; ROWS; i++) { for (int j = 0; j \u0026lt; COLS; j++) { int cur; if (!fscanf(fp, \u0026#34;%d\u0026#34;, \u0026amp;cur)) { printf(\u0026#34;FAIL\u0026#34;); } count++; array[i * COLS + j] = cur; } } // close the input file fclose(fp); printf(\u0026#34;count: %d\\n\u0026#34;, count); } void generate_hooks_with_size(struct Tuple *xy) // generates points along a circle { double r = (WHEEL_PIXEL_SIZE / 2.0) - 1.0; double *theta = (double *)malloc((N_HOOKS) * sizeof(double)); double epsilon = asin(HOOK_PIXEL_SIZE / WHEEL_PIXEL_SIZE); for (int i = 0; i \u0026lt; (N_HOOKS \u0026gt;\u0026gt; 1); i++) { double angle = (double)i / (double)(N_HOOKS \u0026gt;\u0026gt; 1) * (2.0 * M_PI); theta[i * 2] = angle - epsilon; theta[i * 2 + 1] = angle + epsilon; } for (int j = 0; j \u0026lt; N_HOOKS; j++) { struct Tuple point; point.x = r * (1.0 + cos(theta[j])) + 0.5; point.y = r * (1.0 + sin(theta[j])) + 0.5; xy[j] = point; } free(theta); } void through_pixels(struct Tuple p0, struct Tuple p1, struct LinkedList *pixels) { int x0 = p0.x; int y0 = p0.y; int x1 = p1.x; int y1 = p1.y; int dx = abs(x1 - x0); int dy = abs(y1 - y0); int sx = (x0 \u0026lt; x1) ? 1 : -1; int sy = (y0 \u0026lt; y1) ? 1 : -1; int err = dx - dy; while (1) { struct Tuple point; point.x = x0; point.y = y0; append(pixels, point); if (x0 == x1 \u0026amp;\u0026amp; y0 == y1) { return; } int e2 = 2 * err; if (e2 \u0026gt; -dy) { err -= dy; x0 += sx; } if (e2 \u0026lt; dx) { err += dx; y0 += sy; } else if (e2 == dx) { // Handle cases with slope 1 or -1 err -= dy; x0 += sx; err += dx; y0 += sy; } } } // takes image assuming it has been preprocessed for weights int calculate_penalty(int cur, int weight) { if (cur \u0026lt; 0) { // // DEBUG______________________________ // return (weight \u0026lt; 0) ? 0 : ((int)(-cur * 0.25) \u0026gt;\u0026gt; weight); // // DEBUG______________________________ return (weight \u0026lt; 0) ? 0 : -((cur \u0026gt;\u0026gt; LIGHTNESS_PENALTY) \u0026gt;\u0026gt; weight); } else { return (weight \u0026lt; 0) ? 0 : (cur \u0026gt;\u0026gt; weight); } } void generate_unique_random_numbers(int min, int max, int exclude, int N, int *result) { int range = max - min + 1; int adjusted_range = range - (exclude \u0026gt;= min \u0026amp;\u0026amp; exclude \u0026lt;= max); if (N \u0026gt; adjusted_range) { printf(\u0026#34;Error: Cannot generate %d unique random numbers in the given range.\\n\u0026#34;, N); return; } int *flags = (int *)calloc(range, sizeof(int)); flags[exclude - min] = 1; for (int i = 0; i \u0026lt; N; i++) { int rand_num; do { rand_num = rand() % range + min; } while (flags[rand_num - min]); flags[rand_num - min] = 1; result[i] = rand_num; } free(flags); } void optimise_fitness(int *image, int *weight, int *previous_edge, struct Tuple *xy) { int starting_edge = *previous_edge; int count = 0; // randomly chose a subset of endpoints int *chosen = (int *)malloc(TIME_SAVER * sizeof(int)); generate_unique_random_numbers(0, N_HOOKS - 1, starting_edge, TIME_SAVER, chosen); // // DEBUG______________________________ // for (int ii = 0; ii \u0026lt; TIME_SAVER; ii ++){ // printf(\u0026#34;el %d: %d \\n\u0026#34;, ii, chosen[ii]); // } // // DEBUG______________________________ int best_endpoint = -1; int best_reduction = INT_MIN; for (int i = 0; i \u0026lt; TIME_SAVER; i++) { int ending_edge = chosen[i]; struct LinkedList *pixels = initLinkedList(); int penalty_without = 0; int penalty_with = 0; int reduction; through_pixels(xy[starting_edge], xy[ending_edge], pixels); int norm = 0; struct Node *current = pixels-\u0026gt;head; while (current != NULL) { norm++; struct Node *temp = current; int image_data = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; int weight_data; if (temp-\u0026gt;data.y % 2 == 0) { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; } else { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y - 1) * COLS]; } int cur_penalty_without = calculate_penalty(image_data, weight_data); int cur_penalty_with = calculate_penalty(image_data - DARKNESS, weight_data); penalty_with = cur_penalty_with + penalty_with; penalty_without = cur_penalty_without + penalty_without; current = current-\u0026gt;next; free(temp); } free(pixels); reduction = (penalty_without - penalty_with) / norm; if (reduction \u0026gt; best_reduction) { best_reduction = reduction; best_endpoint = ending_edge; } } free(chosen); *previous_edge = best_endpoint; } void update_image(int *image, struct Tuple *xy, int start, int end) { struct LinkedList *pixels = initLinkedList(); through_pixels(xy[start], xy[end], pixels); struct Node *current = pixels-\u0026gt;head; while (current != NULL) { struct Node *temp = current; image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] - DARKNESS; current = current-\u0026gt;next; free(temp); } free(pixels); } void find_lines(int *image, int *weight, struct Tuple *xy, struct Tuple *line_list) { int next_edge_value = rand() % N_HOOKS; int *next_edge = \u0026amp;next_edge_value; for (int i = 0; i \u0026lt; N_LINES; i++) { int previous_edge = *next_edge; optimise_fitness(image, weight, next_edge, xy); update_image(image, xy, previous_edge, *next_edge); line_list[i * 2] = xy[previous_edge]; line_list[i * 2 + 1] = xy[*next_edge]; } } void p_t(struct Tuple point) { printf(\u0026#34;%d, %d\u0026#34;, point.x, point.y); } int main() { // static seed for testing srand(42); clock_t start, end; double cpu_time_used; start = clock(); printf(\u0026#34;Generating Hooks\\n\u0026#34;); struct Tuple *xy = (struct Tuple *)malloc(N_HOOKS * sizeof(struct Tuple)); generate_hooks_with_size(xy); printf(\u0026#34;Reading Image Data\\n\u0026#34;); int *ah_monochrome = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_monochrome, \u0026#34;monalisa.txt\u0026#34;); printf(\u0026#34;Reading Weight Data\\n\u0026#34;); int *ah_weights = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_weights, \u0026#34;ah_wpos.txt\u0026#34;); // COMMENT WHEN USING WEIGHTS // for (int j = 0; j \u0026lt; ROWS; j++){ // for (int k = 0; k \u0026lt; COLS; k++){ // ah_weights[j*COLS+k] = 0; // } // } printf(\u0026#34;Allocating connections list and running optimizer\\n\u0026#34;); struct Tuple *line_list = (struct Tuple *)malloc(N_LINES * sizeof(struct Tuple) * 2); find_lines(ah_monochrome, ah_weights, xy, line_list); // Open the file for writing printf(\u0026#34;Done, writing output file\\n\u0026#34;); FILE *file = fopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening the file.\\n\u0026#34;); return 1; } // Write the array elements to the file for (int i = 0; i \u0026lt; N_LINES; i++) { fprintf(file, \u0026#34;%d\u0026#34;, line_list[i * 2].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2].y); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].y); // Use a newline character instead of a comma to separate elements if (i \u0026lt; N_LINES - 1) { fprintf(file, \u0026#34;\\n\u0026#34;); } } // Close the file fclose(file); printf(\u0026#34;Array written to the output.txt file.\\n\u0026#34;); free(line_list); free(xy); free(ah_monochrome); free(ah_weights); end = clock(); cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC; printf(\u0026#34;Memory freed, used %f CPU time\\n\u0026#34;, cpu_time_used); return 0; } "},{"id":5,"href":"/docs/appendix/gallery/","title":"Gallery","section":"Appendix","content":"\rGallery\r#\rAnimated Gallery\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":6,"href":"/docs/","title":"Docs","section":"Home","content":""},{"id":7,"href":"/docs/appendix/commented-code/hps/","title":"HPS","section":"Commented Code","content":"\u003c!DOCTYPE html\u003e notebooks_Intro \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; /\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; | Copyright (c) Jupyter Development Team. | Distributed under the terms of the Modified BSD License. |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-/\n/* The following CSS variables define the main, public API for styling JupyterLab. These variables should be used by all plugins wherever possible. In other words, plugins should not define custom colors, sizes, etc unless absolutely necessary. This enables users to change the visual theme of JupyterLab by changing these variables.\nMany variables appear in an ordered sequence (0,1,2,3). These sequences are designed to work well together, so for example, --jp-border-color1 should be used with --jp-layout-color1. The numbers have the following meanings:\n0: super-primary, reserved for special emphasis 1: primary, most important under normal situations 2: secondary, next most important under normal situations 3: tertiary, next most important under normal situations Throughout JupyterLab, we are mostly following principles from Google\u0026rsquo;s Material Design when selecting colors. We are not, however, following all of MD as it is not optimized for dense, information rich UIs. */\n:root { /* Elevation *\nWe style box-shadows using Material Design\u0026rsquo;s idea of elevation. These particular numbers are taken from here: https://github.com/material-components/material-components-web https://material-components-web.appspot.com/elevation.html */ \u0026ndash;jp-shadow-base-lightness: 0; \u0026ndash;jp-shadow-umbra-color: rgba( var(\u0026ndash;jp-shadow-base-lightness), var(\u0026ndash;jp-shadow-base-lightness), var(\u0026ndash;jp-shadow-base-lightness), 0.2 ); \u0026ndash;jp-shadow-penumbra-color: rgba( var(\u0026ndash;jp-shadow-base-lightness), var(\u0026ndash;jp-shadow-base-lightness), var(\u0026ndash;jp-shadow-base-lightness), 0.14 ); \u0026ndash;jp-shadow-ambient-color: rgba( var(\u0026ndash;jp-shadow-base-lightness), var(\u0026ndash;jp-shadow-base-lightness), var(\u0026ndash;jp-shadow-base-lightness), 0.12 ); \u0026ndash;jp-elevation-z0: none; \u0026ndash;jp-elevation-z1: 0px 2px 1px -1px var(\u0026ndash;jp-shadow-umbra-color), 0px 1px 1px 0px var(\u0026ndash;jp-shadow-penumbra-color), 0px 1px 3px 0px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z2: 0px 3px 1px -2px var(\u0026ndash;jp-shadow-umbra-color), 0px 2px 2px 0px var(\u0026ndash;jp-shadow-penumbra-color), 0px 1px 5px 0px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z4: 0px 2px 4px -1px var(\u0026ndash;jp-shadow-umbra-color), 0px 4px 5px 0px var(\u0026ndash;jp-shadow-penumbra-color), 0px 1px 10px 0px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z6: 0px 3px 5px -1px var(\u0026ndash;jp-shadow-umbra-color), 0px 6px 10px 0px var(\u0026ndash;jp-shadow-penumbra-color), 0px 1px 18px 0px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z8: 0px 5px 5px -3px var(\u0026ndash;jp-shadow-umbra-color), 0px 8px 10px 1px var(\u0026ndash;jp-shadow-penumbra-color), 0px 3px 14px 2px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z12: 0px 7px 8px -4px var(\u0026ndash;jp-shadow-umbra-color), 0px 12px 17px 2px var(\u0026ndash;jp-shadow-penumbra-color), 0px 5px 22px 4px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z16: 0px 8px 10px -5px var(\u0026ndash;jp-shadow-umbra-color), 0px 16px 24px 2px var(\u0026ndash;jp-shadow-penumbra-color), 0px 6px 30px 5px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z20: 0px 10px 13px -6px var(\u0026ndash;jp-shadow-umbra-color), 0px 20px 31px 3px var(\u0026ndash;jp-shadow-penumbra-color), 0px 8px 38px 7px var(\u0026ndash;jp-shadow-ambient-color); \u0026ndash;jp-elevation-z24: 0px 11px 15px -7px var(\u0026ndash;jp-shadow-umbra-color), 0px 24px 38px 3px var(\u0026ndash;jp-shadow-penumbra-color), 0px 9px 46px 8px var(\u0026ndash;jp-shadow-ambient-color);\n/* Borders *\nThe following variables, specify the visual styling of borders in JupyterLab. */ \u0026ndash;jp-border-width: 1px; \u0026ndash;jp-border-color0: var(\u0026ndash;md-grey-400); \u0026ndash;jp-border-color1: var(\u0026ndash;md-grey-400); \u0026ndash;jp-border-color2: var(\u0026ndash;md-grey-300); \u0026ndash;jp-border-color3: var(\u0026ndash;md-grey-200); \u0026ndash;jp-inverse-border-color: var(\u0026ndash;md-grey-600); \u0026ndash;jp-border-radius: 2px;\n/* UI Fonts *\nThe UI font CSS variables are used for the typography all of the JupyterLab user interface elements that are not directly user generated content. The font sizing here is done assuming that the body font size of \u0026ndash;jp-ui-font-size1 is applied to a parent element. When children elements, such as headings, are sized in em all things will be computed relative to that body size. */ \u0026ndash;jp-ui-font-scale-factor: 1.2; \u0026ndash;jp-ui-font-size0: 0.83333em; \u0026ndash;jp-ui-font-size1: 13px; /* Base font size */ \u0026ndash;jp-ui-font-size2: 1.2em; \u0026ndash;jp-ui-font-size3: 1.44em;\n\u0026ndash;jp-ui-font-family: -apple-system, BlinkMacSystemFont, \u0026lsquo;Segoe UI\u0026rsquo;, Helvetica, Arial, sans-serif, \u0026lsquo;Apple Color Emoji\u0026rsquo;, \u0026lsquo;Segoe UI Emoji\u0026rsquo;, \u0026lsquo;Segoe UI Symbol\u0026rsquo;;\n/*\nUse these font colors against the corresponding main layout colors. In a light theme, these go from dark to light. */ /* Defaults use Material Design specification */ \u0026ndash;jp-ui-font-color0: rgba(0, 0, 0, 1); \u0026ndash;jp-ui-font-color1: rgba(0, 0, 0, 0.87); \u0026ndash;jp-ui-font-color2: rgba(0, 0, 0, 0.54); \u0026ndash;jp-ui-font-color3: rgba(0, 0, 0, 0.38);\n/*\nUse these against the brand/accent/warn/error colors. These will typically go from light to darker, in both a dark and light theme. */ \u0026ndash;jp-ui-inverse-font-color0: rgba(255, 255, 255, 1); \u0026ndash;jp-ui-inverse-font-color1: rgba(255, 255, 255, 1); \u0026ndash;jp-ui-inverse-font-color2: rgba(255, 255, 255, 0.7); \u0026ndash;jp-ui-inverse-font-color3: rgba(255, 255, 255, 0.5);\n/* Content Fonts *\nContent font variables are used for typography of user generated content. The font sizing here is done assuming that the body font size of \u0026ndash;jp-content-font-size1 is applied to a parent element. When children elements, such as headings, are sized in em all things will be computed relative to that body size. */ \u0026ndash;jp-content-line-height: 1.6; \u0026ndash;jp-content-font-scale-factor: 1.2; \u0026ndash;jp-content-font-size0: 0.83333em; \u0026ndash;jp-content-font-size1: 14px; /* Base font size */ \u0026ndash;jp-content-font-size2: 1.2em; \u0026ndash;jp-content-font-size3: 1.44em; \u0026ndash;jp-content-font-size4: 1.728em; \u0026ndash;jp-content-font-size5: 2.0736em;\n/* This gives a magnification of about 125% in presentation mode over normal. */ \u0026ndash;jp-content-presentation-font-size1: 17px;\n\u0026ndash;jp-content-heading-line-height: 1; \u0026ndash;jp-content-heading-margin-top: 1.2em; \u0026ndash;jp-content-heading-margin-bottom: 0.8em; \u0026ndash;jp-content-heading-font-weight: 500;\n/* Defaults use Material Design specification */ \u0026ndash;jp-content-font-color0: rgba(0, 0, 0, 1); \u0026ndash;jp-content-font-color1: rgba(0, 0, 0, 0.87); \u0026ndash;jp-content-font-color2: rgba(0, 0, 0, 0.54); \u0026ndash;jp-content-font-color3: rgba(0, 0, 0, 0.38);\n\u0026ndash;jp-content-link-color: var(\u0026ndash;md-blue-700);\n\u0026ndash;jp-content-font-family: -apple-system, BlinkMacSystemFont, \u0026lsquo;Segoe UI\u0026rsquo;, Helvetica, Arial, sans-serif, \u0026lsquo;Apple Color Emoji\u0026rsquo;, \u0026lsquo;Segoe UI Emoji\u0026rsquo;, \u0026lsquo;Segoe UI Symbol\u0026rsquo;;\n/*\nCode Fonts Code font variables are used for typography of code and other monospaces content. */ \u0026ndash;jp-code-font-size: 13px; \u0026ndash;jp-code-line-height: 1.3077; /* 17px for 13px base / \u0026ndash;jp-code-padding: 5px; / 5px for 13px base, codemirror highlighting needs integer px value */ \u0026ndash;jp-code-font-family-default: Menlo, Consolas, \u0026lsquo;DejaVu Sans Mono\u0026rsquo;, monospace; \u0026ndash;jp-code-font-family: var(\u0026ndash;jp-code-font-family-default);\n/* This gives a magnification of about 125% in presentation mode over normal. */ \u0026ndash;jp-code-presentation-font-size: 16px;\n/* may need to tweak cursor width if you change font size */ \u0026ndash;jp-code-cursor-width0: 1.4px; \u0026ndash;jp-code-cursor-width1: 2px; \u0026ndash;jp-code-cursor-width2: 4px;\n/* Layout *\nThe following are the main layout colors use in JupyterLab. In a light theme these would go from light to dark. */ \u0026ndash;jp-layout-color0: white; \u0026ndash;jp-layout-color1: white; \u0026ndash;jp-layout-color2: var(\u0026ndash;md-grey-200); \u0026ndash;jp-layout-color3: var(\u0026ndash;md-grey-400); \u0026ndash;jp-layout-color4: var(\u0026ndash;md-grey-600);\n/* Inverse Layout *\nThe following are the inverse layout colors use in JupyterLab. In a light theme these would go from dark to light. */ \u0026ndash;jp-inverse-layout-color0: #111111; \u0026ndash;jp-inverse-layout-color1: var(\u0026ndash;md-grey-900); \u0026ndash;jp-inverse-layout-color2: var(\u0026ndash;md-grey-800); \u0026ndash;jp-inverse-layout-color3: var(\u0026ndash;md-grey-700); \u0026ndash;jp-inverse-layout-color4: var(\u0026ndash;md-grey-600);\n/* Brand/accent */\n\u0026ndash;jp-brand-color0: var(\u0026ndash;md-blue-900); \u0026ndash;jp-brand-color1: var(\u0026ndash;md-blue-700); \u0026ndash;jp-brand-color2: var(\u0026ndash;md-blue-300); \u0026ndash;jp-brand-color3: var(\u0026ndash;md-blue-100); \u0026ndash;jp-brand-color4: var(\u0026ndash;md-blue-50);\n\u0026ndash;jp-accent-color0: var(\u0026ndash;md-green-900); \u0026ndash;jp-accent-color1: var(\u0026ndash;md-green-700); \u0026ndash;jp-accent-color2: var(\u0026ndash;md-green-300); \u0026ndash;jp-accent-color3: var(\u0026ndash;md-green-100);\n/* State colors (warn, error, success, info) */\n\u0026ndash;jp-warn-color0: var(\u0026ndash;md-orange-900); \u0026ndash;jp-warn-color1: var(\u0026ndash;md-orange-700); \u0026ndash;jp-warn-color2: var(\u0026ndash;md-orange-300); \u0026ndash;jp-warn-color3: var(\u0026ndash;md-orange-100);\n\u0026ndash;jp-error-color0: var(\u0026ndash;md-red-900); \u0026ndash;jp-error-color1: var(\u0026ndash;md-red-700); \u0026ndash;jp-error-color2: var(\u0026ndash;md-red-300); \u0026ndash;jp-error-color3: var(\u0026ndash;md-red-100);\n\u0026ndash;jp-success-color0: var(\u0026ndash;md-green-900); \u0026ndash;jp-success-color1: var(\u0026ndash;md-green-700); \u0026ndash;jp-success-color2: var(\u0026ndash;md-green-300); \u0026ndash;jp-success-color3: var(\u0026ndash;md-green-100);\n\u0026ndash;jp-info-color0: var(\u0026ndash;md-cyan-900); \u0026ndash;jp-info-color1: var(\u0026ndash;md-cyan-700); \u0026ndash;jp-info-color2: var(\u0026ndash;md-cyan-300); \u0026ndash;jp-info-color3: var(\u0026ndash;md-cyan-100);\n/* Cell specific styles */\n\u0026ndash;jp-cell-padding: 5px;\n\u0026ndash;jp-cell-collapser-width: 8px; \u0026ndash;jp-cell-collapser-min-height: 20px; \u0026ndash;jp-cell-collapser-not-active-hover-opacity: 0.6;\n\u0026ndash;jp-cell-editor-background: var(\u0026ndash;md-grey-100); \u0026ndash;jp-cell-editor-border-color: var(\u0026ndash;md-grey-300); \u0026ndash;jp-cell-editor-box-shadow: inset 0 0 2px var(\u0026ndash;md-blue-300); \u0026ndash;jp-cell-editor-active-background: var(\u0026ndash;jp-layout-color0); \u0026ndash;jp-cell-editor-active-border-color: var(\u0026ndash;jp-brand-color1);\n\u0026ndash;jp-cell-prompt-width: 64px; \u0026ndash;jp-cell-prompt-font-family: var(\u0026ndash;jp-code-font-family-default); \u0026ndash;jp-cell-prompt-letter-spacing: 0px; \u0026ndash;jp-cell-prompt-opacity: 1; \u0026ndash;jp-cell-prompt-not-active-opacity: 0.5; \u0026ndash;jp-cell-prompt-not-active-font-color: var(\u0026ndash;md-grey-700); /* A custom blend of MD grey and blue 600\nSee https://meyerweb.com/eric/tools/color-blend/#546E7A:1E88E5:5:hex / \u0026ndash;jp-cell-inprompt-font-color: #307fc1; / A custom blend of MD grey and orange 600 https://meyerweb.com/eric/tools/color-blend/#546E7A:F4511E:5:hex */ \u0026ndash;jp-cell-outprompt-font-color: #bf5b3d; /* Notebook specific styles */\n\u0026ndash;jp-notebook-padding: 10px; \u0026ndash;jp-notebook-select-background: var(\u0026ndash;jp-layout-color1); \u0026ndash;jp-notebook-multiselected-color: var(\u0026ndash;md-blue-50);\n/* The scroll padding is calculated to fill enough space at the bottom of the notebook to show one single-line cell (with appropriate padding) at the top when the notebook is scrolled all the way to the bottom. We also subtract one pixel so that no scrollbar appears if we have just one single-line cell in the notebook. This padding is to enable a \u0026lsquo;scroll past end\u0026rsquo; feature in a notebook. */ \u0026ndash;jp-notebook-scroll-padding: calc( 100% - var(\u0026ndash;jp-code-font-size) * var(\u0026ndash;jp-code-line-height) - var(\u0026ndash;jp-code-padding) - var(\u0026ndash;jp-cell-padding) - 1px );\n/* Rendermime styles */\n\u0026ndash;jp-rendermime-error-background: #fdd; \u0026ndash;jp-rendermime-table-row-background: var(\u0026ndash;md-grey-100); \u0026ndash;jp-rendermime-table-row-hover-background: var(\u0026ndash;md-light-blue-50);\n/* Dialog specific styles */\n\u0026ndash;jp-dialog-background: rgba(0, 0, 0, 0.25);\n/* Console specific styles */\n\u0026ndash;jp-console-padding: 10px;\n/* Toolbar specific styles */\n\u0026ndash;jp-toolbar-border-color: var(\u0026ndash;jp-border-color1); \u0026ndash;jp-toolbar-micro-height: 8px; \u0026ndash;jp-toolbar-background: var(\u0026ndash;jp-layout-color1); \u0026ndash;jp-toolbar-box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.24); \u0026ndash;jp-toolbar-header-margin: 4px 4px 0px 4px; \u0026ndash;jp-toolbar-active-background: var(\u0026ndash;md-grey-300);\n/* Statusbar specific styles */\n\u0026ndash;jp-statusbar-height: 24px;\n/* Input field styles */\n\u0026ndash;jp-input-box-shadow: inset 0 0 2px var(\u0026ndash;md-blue-300); \u0026ndash;jp-input-active-background: var(\u0026ndash;jp-layout-color1); \u0026ndash;jp-input-hover-background: var(\u0026ndash;jp-layout-color1); \u0026ndash;jp-input-background: var(\u0026ndash;md-grey-100); \u0026ndash;jp-input-border-color: var(\u0026ndash;jp-inverse-border-color); \u0026ndash;jp-input-active-border-color: var(\u0026ndash;jp-brand-color1); \u0026ndash;jp-input-active-box-shadow-color: rgba(19, 124, 189, 0.3);\n/* General editor styles */\n\u0026ndash;jp-editor-selected-background: #d9d9d9; \u0026ndash;jp-editor-selected-focused-background: #d7d4f0; \u0026ndash;jp-editor-cursor-color: var(\u0026ndash;jp-ui-font-color0);\n/* Code mirror specific styles */\n\u0026ndash;jp-mirror-editor-keyword-color: #008000; \u0026ndash;jp-mirror-editor-atom-color: #88f; \u0026ndash;jp-mirror-editor-number-color: #080; \u0026ndash;jp-mirror-editor-def-color: #00f; \u0026ndash;jp-mirror-editor-variable-color: var(\u0026ndash;md-grey-900); \u0026ndash;jp-mirror-editor-variable-2-color: #05a; \u0026ndash;jp-mirror-editor-variable-3-color: #085; \u0026ndash;jp-mirror-editor-punctuation-color: #05a; \u0026ndash;jp-mirror-editor-property-color: #05a; \u0026ndash;jp-mirror-editor-operator-color: #aa22ff; \u0026ndash;jp-mirror-editor-comment-color: #408080; \u0026ndash;jp-mirror-editor-string-color: #ba2121; \u0026ndash;jp-mirror-editor-string-2-color: #708; \u0026ndash;jp-mirror-editor-meta-color: #aa22ff; \u0026ndash;jp-mirror-editor-qualifier-color: #555; \u0026ndash;jp-mirror-editor-builtin-color: #008000; \u0026ndash;jp-mirror-editor-bracket-color: #997; \u0026ndash;jp-mirror-editor-tag-color: #170; \u0026ndash;jp-mirror-editor-attribute-color: #00c; \u0026ndash;jp-mirror-editor-header-color: blue; \u0026ndash;jp-mirror-editor-quote-color: #090; \u0026ndash;jp-mirror-editor-link-color: #00c; \u0026ndash;jp-mirror-editor-error-color: #f00; \u0026ndash;jp-mirror-editor-hr-color: #999;\n/* RTC user specific colors. These colors are used for the cursor, username in the editor, and the icon of the user. */\n\u0026ndash;jp-collaborator-color1: #ffad8e; \u0026ndash;jp-collaborator-color2: #dac83d; \u0026ndash;jp-collaborator-color3: #72dd76; \u0026ndash;jp-collaborator-color4: #00e4d0; \u0026ndash;jp-collaborator-color5: #45d4ff; \u0026ndash;jp-collaborator-color6: #e2b1ff; \u0026ndash;jp-collaborator-color7: #ff9de6;\n/* Vega extension styles */\n\u0026ndash;jp-vega-background: white;\n/* Sidebar-related styles */\n\u0026ndash;jp-sidebar-min-width: 250px;\n/* Search-related styles */\n\u0026ndash;jp-search-toggle-off-opacity: 0.5; \u0026ndash;jp-search-toggle-hover-opacity: 0.8; \u0026ndash;jp-search-toggle-on-opacity: 1; \u0026ndash;jp-search-selected-match-background-color: rgb(245, 200, 0); \u0026ndash;jp-search-selected-match-color: black; \u0026ndash;jp-search-unselected-match-background-color: var( \u0026ndash;jp-inverse-layout-color0 ); \u0026ndash;jp-search-unselected-match-color: var(\u0026ndash;jp-ui-inverse-font-color0);\n/* Icon colors that work well with light or dark backgrounds */ \u0026ndash;jp-icon-contrast-color0: var(\u0026ndash;md-purple-600); \u0026ndash;jp-icon-contrast-color1: var(\u0026ndash;md-green-600); \u0026ndash;jp-icon-contrast-color2: var(\u0026ndash;md-pink-600); \u0026ndash;jp-icon-contrast-color3: var(\u0026ndash;md-blue-600);\n/* File or activity icons and switch semantic variables */ \u0026ndash;jp-jupyter-icon-color: #f37626; \u0026ndash;jp-notebook-icon-color: #f37626; \u0026ndash;jp-json-icon-color: var(\u0026ndash;md-orange-700); \u0026ndash;jp-console-icon-background-color: var(\u0026ndash;md-blue-700); \u0026ndash;jp-console-icon-color: white; \u0026ndash;jp-terminal-icon-background-color: var(\u0026ndash;md-grey-800); \u0026ndash;jp-terminal-icon-color: var(\u0026ndash;md-grey-200); \u0026ndash;jp-text-editor-icon-color: var(\u0026ndash;md-grey-700); \u0026ndash;jp-inspector-icon-color: var(\u0026ndash;md-grey-700); \u0026ndash;jp-switch-color: var(\u0026ndash;md-grey-400); \u0026ndash;jp-switch-true-position-color: var(\u0026ndash;md-orange-900); } \u0026lt;script src=\u0026quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML-full,Safe\u0026quot;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;!-- MathJax configuration --\u0026gt; \u0026lt;script type=\u0026quot;text/x-mathjax-config\u0026quot;\u0026gt; init_mathjax = function() { if (window.MathJax) { // MathJax loaded MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: \u0026quot;AMS\u0026quot;, useLabelIds: true } }, tex2jax: { inlineMath: [ ['$','$'], [\u0026quot;\\\\(\u0026quot;,\u0026quot;\\\\)\u0026quot;] ], displayMath: [ ['$$','$$'], [\u0026quot;\\\\[\u0026quot;,\u0026quot;\\\\]\u0026quot;] ], processEscapes: true, processEnvironments: true }, displayAlign: 'center', CommonHTML: { linebreaks: { automatic: true } } }); MathJax.Hub.Queue([\u0026quot;Typeset\u0026quot;, MathJax.Hub]); } } init_mathjax(); \u0026lt;/script\u0026gt; \u0026lt;!-- End of mathjax configuration --\u0026gt;\u0026lt;/head\u0026gt; Introduction to the JupyterLab and Jupyter Notebooks\u0026#182;This is a short introduction to two of the flagship tools created by the Jupyter Community.\n⚠️Experimental!⚠️: This is an experimental interface provided by the JupyterLite project. It embeds an entire JupyterLab interface, with many popular packages for scientific computing, in your browser. There may be minor differences in behavior between JupyterLite and the JupyterLab you install locally. You may also encounter some bugs or unexpected behavior. To report any issues, or to get involved with the JupyterLite project, see the JupyterLite repository.\nJupyterLab \u0026#129514;\u0026#182;JupyterLab is a next-generation web-based user interface for Project Jupyter. It enables you to work with documents and activities such as Jupyter notebooks, text editors, terminals, and custom components in a flexible, integrated, and extensible manner. It is the interface that you're looking at right now.\nFor an overview of the JupyterLab interface, see the JupyterLab Welcome Tour on this page, by going to Help -\u0026gt; Welcome Tour and following the prompts.\nSee Also: For a more in-depth tour of JupyterLab with a full environment that runs in the cloud, see the JupyterLab introduction on Binder.\nJupyter Notebooks \u0026#128211;\u0026#182;Jupyter Notebooks are a community standard for communicating and performing interactive computing. They are a document that blends computations, outputs, explanatory text, mathematics, images, and rich media representations of objects.\nJupyterLab is one interface used to create and interact with Jupyter Notebooks.\nFor an overview of Jupyter Notebooks, see the JupyterLab Welcome Tour on this page, by going to Help -\u0026gt; Notebook Tour and following the prompts.\nSee Also: For a more in-depth tour of Jupyter Notebooks and the Classic Jupyter Notebook interface, see the Jupyter Notebook IPython tutorial on Binder.\nAn example: visualizing data in the notebook \u0026#10024;\u0026#182;Below is an example of a code cell. We'll visualize some simple data using two popular packages in Python. We'll use NumPy to create some random data, and Matplotlib to visualize it.\nNote how the code and the results of running the code are bundled together.\nIn\u0026nbsp;[1]: from matplotlib import pyplot as plt import numpy as np # Generate 100 random data points along 3 dimensions x, y, scale = np.random.randn(3, 100) fig, ax = plt.subplots()\n# Map each onto a scatterplot we'll create with Matplotlib ax.scatter(x=x, y=y, c=scale, s=np.abs(scale)*500) ax.set(title=\u0026quot;Some random data, created with JupyterLab!\u0026quot;) plt.show() \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;jp-OutputPrompt jp-OutputArea-prompt\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; Next steps \u0026#127939;\u0026#182;This is just a short introduction to JupyterLab and Jupyter Notebooks. See below for some more ways to interact with tools in the Jupyter ecosystem, and its community.\nOther notebooks in this demo\u0026#182;Here are some other notebooks in this demo. Each of the items below corresponds to a file or folder in the file browser to the left.\nLorenz.ipynb uses Python to demonstrate interactive visualizations and computations around the Lorenz system. It shows off basic Python functionality, including more visualizations, data structures, and scientific computing libraries. sqlite.ipynb demonstrates how an in-browser sqlite kernel to run your own SQL commands from the notebook. It uses the jupyterlite/xeus-sqlite-kernel. Other sources of information in Jupyter\u0026#182; More on using JupyterLab: See the JupyterLab documentation for more thorough information about how to install and use JupyterLab. More interactive demos: See try.jupyter.org for more interactive demos with the Jupyter ecosystem. Learn more about Jupyter: See the Jupyter community documentation to learn more about the project, its community and tools, and how to get involved. Join our discussions: The Jupyter Community Forum is a place where many in the Jupyter community ask questions, help one another, and discuss issues around interactive computing and our ecosystem. "}]