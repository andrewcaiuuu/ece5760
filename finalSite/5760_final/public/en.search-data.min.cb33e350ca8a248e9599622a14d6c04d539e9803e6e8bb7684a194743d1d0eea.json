[{"id":0,"href":"/docs/appendix/commented-code/","title":"Commented Code","section":"Appendix","content":""},{"id":1,"href":"/docs/appendix/","title":"Appendix","section":"Docs","content":""},{"id":2,"href":"/docs/appendix/commented-code/c-implementation/","title":"C Implementation","section":"Commented Code","content":"\rC implementation\r#\r// compile with gcc thread_art.c -o out -O2 -lm -std=c99 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define WHEEL_PIXEL_SIZE 1600 #define N_HOOKS 160 // needs to be divisible by 2 #define HOOK_PIXEL_SIZE 3 #define ROWS 1600 #define COLS 1600 #define N_LINES 800 #define LIGHTNESS_PENALTY 1 // defined in terms of right shifts #define DARKNESS 800 #define TIME_SAVER 40 // defined as terms to actually consider #ifndef M_PI #define M_PI 3.14159265358979323846 #endif #ifndef INT_MIN #define INT_MIN -2147483648 #endif // HELPER STUFF struct Tuple { int x; int y; }; struct Node { struct Tuple data; struct Node *next; }; struct LinkedList { struct Node *head; struct Node *tail; }; struct LinkedList *initLinkedList() { struct LinkedList *list = (struct LinkedList *)malloc(sizeof(struct LinkedList)); list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; return list; } void freeList(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; while (current != NULL) { struct Node *temp = current; current = current-\u0026gt;next; free(temp); } free(list); } void append(struct LinkedList *list, struct Tuple data) { // allocate memory for the new node struct Node *new_node = (struct Node *)malloc(sizeof(struct Node)); // set the data of the new node new_node-\u0026gt;data = data; // set the next pointer of the new node to NULL new_node-\u0026gt;next = NULL; // if the list is empty, set the new node as the head and tail of the list if (list-\u0026gt;head == NULL) { list-\u0026gt;head = new_node; list-\u0026gt;tail = new_node; } // otherwise, append the new node to the tail of the list else { list-\u0026gt;tail-\u0026gt;next = new_node; list-\u0026gt;tail = new_node; } } void print_list(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; int idx = 0; while (current != NULL) { printf(\u0026#34;idx %d: (%d, %d)\\n\u0026#34;, idx, current-\u0026gt;data.x, current-\u0026gt;data.y); idx++; current = current-\u0026gt;next; } } // END HELPER STUFF void read_array(int *array, char *path) { // open the input file FILE *fp = fopen(path, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;Failed to open file \\n\u0026#34;); } int count = 0; // read the integers from the file into the array for (int i = 0; i \u0026lt; ROWS; i++) { for (int j = 0; j \u0026lt; COLS; j++) { int cur; if (!fscanf(fp, \u0026#34;%d\u0026#34;, \u0026amp;cur)) { printf(\u0026#34;FAIL\u0026#34;); } count++; array[i * COLS + j] = cur; } } // close the input file fclose(fp); printf(\u0026#34;count: %d\\n\u0026#34;, count); } void generate_hooks_with_size(struct Tuple *xy) // generates points along a circle { double r = (WHEEL_PIXEL_SIZE / 2.0) - 1.0; double *theta = (double *)malloc((N_HOOKS) * sizeof(double)); double epsilon = asin(HOOK_PIXEL_SIZE / WHEEL_PIXEL_SIZE); for (int i = 0; i \u0026lt; (N_HOOKS \u0026gt;\u0026gt; 1); i++) { double angle = (double)i / (double)(N_HOOKS \u0026gt;\u0026gt; 1) * (2.0 * M_PI); theta[i * 2] = angle - epsilon; theta[i * 2 + 1] = angle + epsilon; } for (int j = 0; j \u0026lt; N_HOOKS; j++) { struct Tuple point; point.x = r * (1.0 + cos(theta[j])) + 0.5; point.y = r * (1.0 + sin(theta[j])) + 0.5; xy[j] = point; } free(theta); } void through_pixels(struct Tuple p0, struct Tuple p1, struct LinkedList *pixels) { int x0 = p0.x; int y0 = p0.y; int x1 = p1.x; int y1 = p1.y; int dx = abs(x1 - x0); int dy = abs(y1 - y0); int sx = (x0 \u0026lt; x1) ? 1 : -1; int sy = (y0 \u0026lt; y1) ? 1 : -1; int err = dx - dy; while (1) { struct Tuple point; point.x = x0; point.y = y0; append(pixels, point); if (x0 == x1 \u0026amp;\u0026amp; y0 == y1) { return; } int e2 = 2 * err; if (e2 \u0026gt; -dy) { err -= dy; x0 += sx; } if (e2 \u0026lt; dx) { err += dx; y0 += sy; } else if (e2 == dx) { // Handle cases with slope 1 or -1 err -= dy; x0 += sx; err += dx; y0 += sy; } } } // takes image assuming it has been preprocessed for weights int calculate_penalty(int cur, int weight) { if (cur \u0026lt; 0) { // // DEBUG______________________________ // return (weight \u0026lt; 0) ? 0 : ((int)(-cur * 0.25) \u0026gt;\u0026gt; weight); // // DEBUG______________________________ return (weight \u0026lt; 0) ? 0 : -((cur \u0026gt;\u0026gt; LIGHTNESS_PENALTY) \u0026gt;\u0026gt; weight); } else { return (weight \u0026lt; 0) ? 0 : (cur \u0026gt;\u0026gt; weight); } } void generate_unique_random_numbers(int min, int max, int exclude, int N, int *result) { int range = max - min + 1; int adjusted_range = range - (exclude \u0026gt;= min \u0026amp;\u0026amp; exclude \u0026lt;= max); if (N \u0026gt; adjusted_range) { printf(\u0026#34;Error: Cannot generate %d unique random numbers in the given range.\\n\u0026#34;, N); return; } int *flags = (int *)calloc(range, sizeof(int)); flags[exclude - min] = 1; for (int i = 0; i \u0026lt; N; i++) { int rand_num; do { rand_num = rand() % range + min; } while (flags[rand_num - min]); flags[rand_num - min] = 1; result[i] = rand_num; } free(flags); } void optimise_fitness(int *image, int *weight, int *previous_edge, struct Tuple *xy) { int starting_edge = *previous_edge; int count = 0; // randomly chose a subset of endpoints int *chosen = (int *)malloc(TIME_SAVER * sizeof(int)); generate_unique_random_numbers(0, N_HOOKS - 1, starting_edge, TIME_SAVER, chosen); // // DEBUG______________________________ // for (int ii = 0; ii \u0026lt; TIME_SAVER; ii ++){ // printf(\u0026#34;el %d: %d \\n\u0026#34;, ii, chosen[ii]); // } // // DEBUG______________________________ int best_endpoint = -1; int best_reduction = INT_MIN; for (int i = 0; i \u0026lt; TIME_SAVER; i++) { int ending_edge = chosen[i]; struct LinkedList *pixels = initLinkedList(); int penalty_without = 0; int penalty_with = 0; int reduction; through_pixels(xy[starting_edge], xy[ending_edge], pixels); int norm = 0; struct Node *current = pixels-\u0026gt;head; while (current != NULL) { norm++; struct Node *temp = current; int image_data = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; int weight_data; if (temp-\u0026gt;data.y % 2 == 0) { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; } else { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y - 1) * COLS]; } int cur_penalty_without = calculate_penalty(image_data, weight_data); int cur_penalty_with = calculate_penalty(image_data - DARKNESS, weight_data); penalty_with = cur_penalty_with + penalty_with; penalty_without = cur_penalty_without + penalty_without; current = current-\u0026gt;next; free(temp); } free(pixels); reduction = (penalty_without - penalty_with) / norm; if (reduction \u0026gt; best_reduction) { best_reduction = reduction; best_endpoint = ending_edge; } } free(chosen); *previous_edge = best_endpoint; } void update_image(int *image, struct Tuple *xy, int start, int end) { struct LinkedList *pixels = initLinkedList(); through_pixels(xy[start], xy[end], pixels); struct Node *current = pixels-\u0026gt;head; while (current != NULL) { struct Node *temp = current; image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] - DARKNESS; current = current-\u0026gt;next; free(temp); } free(pixels); } void find_lines(int *image, int *weight, struct Tuple *xy, struct Tuple *line_list) { int next_edge_value = rand() % N_HOOKS; int *next_edge = \u0026amp;next_edge_value; for (int i = 0; i \u0026lt; N_LINES; i++) { int previous_edge = *next_edge; optimise_fitness(image, weight, next_edge, xy); update_image(image, xy, previous_edge, *next_edge); line_list[i * 2] = xy[previous_edge]; line_list[i * 2 + 1] = xy[*next_edge]; } } void p_t(struct Tuple point) { printf(\u0026#34;%d, %d\u0026#34;, point.x, point.y); } int main() { // static seed for testing srand(42); clock_t start, end; double cpu_time_used; start = clock(); printf(\u0026#34;Generating Hooks\\n\u0026#34;); struct Tuple *xy = (struct Tuple *)malloc(N_HOOKS * sizeof(struct Tuple)); generate_hooks_with_size(xy); printf(\u0026#34;Reading Image Data\\n\u0026#34;); int *ah_monochrome = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_monochrome, \u0026#34;monalisa.txt\u0026#34;); printf(\u0026#34;Reading Weight Data\\n\u0026#34;); int *ah_weights = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_weights, \u0026#34;ah_wpos.txt\u0026#34;); // COMMENT WHEN USING WEIGHTS // for (int j = 0; j \u0026lt; ROWS; j++){ // for (int k = 0; k \u0026lt; COLS; k++){ // ah_weights[j*COLS+k] = 0; // } // } printf(\u0026#34;Allocating connections list and running optimizer\\n\u0026#34;); struct Tuple *line_list = (struct Tuple *)malloc(N_LINES * sizeof(struct Tuple) * 2); find_lines(ah_monochrome, ah_weights, xy, line_list); // Open the file for writing printf(\u0026#34;Done, writing output file\\n\u0026#34;); FILE *file = fopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening the file.\\n\u0026#34;); return 1; } // Write the array elements to the file for (int i = 0; i \u0026lt; N_LINES; i++) { fprintf(file, \u0026#34;%d\u0026#34;, line_list[i * 2].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2].y); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].y); // Use a newline character instead of a comma to separate elements if (i \u0026lt; N_LINES - 1) { fprintf(file, \u0026#34;\\n\u0026#34;); } } // Close the file fclose(file); printf(\u0026#34;Array written to the output.txt file.\\n\u0026#34;); free(line_list); free(xy); free(ah_monochrome); free(ah_weights); end = clock(); cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC; printf(\u0026#34;Memory freed, used %f CPU time\\n\u0026#34;, cpu_time_used); return 0; } "},{"id":3,"href":"/docs/appendix/gallery/","title":"Gallery","section":"Appendix","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":4,"href":"/docs/","title":"Docs","section":"Home","content":""}]