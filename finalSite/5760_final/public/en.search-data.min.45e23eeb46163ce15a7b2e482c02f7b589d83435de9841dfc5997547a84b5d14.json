[{"id":0,"href":"/docs/appendix/commented-code/","title":"Commented Code","section":"Appendix","content":""},{"id":1,"href":"/docs/appendix/commented-code/verilog-implementation/","title":"Verilog Implementation","section":"Commented Code","content":""},{"id":2,"href":"/docs/appendix/","title":"Appendix","section":"Docs","content":""},{"id":3,"href":"/docs/appendix/commented-code/c-implementation/","title":"C Implementation","section":"Commented Code","content":"// compile with gcc thread_art.c -o out -O2 -lm -std=c99 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define WHEEL_PIXEL_SIZE 1600 #define N_HOOKS 160 // needs to be divisible by 2 #define HOOK_PIXEL_SIZE 3 #define ROWS 1600 #define COLS 1600 #define N_LINES 800 #define LIGHTNESS_PENALTY 1 // defined in terms of right shifts #define DARKNESS 800 #define TIME_SAVER 40 // defined as terms to actually consider #ifndef M_PI #define M_PI 3.14159265358979323846 #endif #ifndef INT_MIN #define INT_MIN -2147483648 #endif // HELPER STUFF struct Tuple { int x; int y; }; struct Node { struct Tuple data; struct Node *next; }; struct LinkedList { struct Node *head; struct Node *tail; }; struct LinkedList *initLinkedList() { struct LinkedList *list = (struct LinkedList *)malloc(sizeof(struct LinkedList)); list-\u0026gt;head = NULL; list-\u0026gt;tail = NULL; return list; } void freeList(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; while (current != NULL) { struct Node *temp = current; current = current-\u0026gt;next; free(temp); } free(list); } void append(struct LinkedList *list, struct Tuple data) { // allocate memory for the new node struct Node *new_node = (struct Node *)malloc(sizeof(struct Node)); // set the data of the new node new_node-\u0026gt;data = data; // set the next pointer of the new node to NULL new_node-\u0026gt;next = NULL; // if the list is empty, set the new node as the head and tail of the list if (list-\u0026gt;head == NULL) { list-\u0026gt;head = new_node; list-\u0026gt;tail = new_node; } // otherwise, append the new node to the tail of the list else { list-\u0026gt;tail-\u0026gt;next = new_node; list-\u0026gt;tail = new_node; } } void print_list(struct LinkedList *list) { struct Node *current = list-\u0026gt;head; int idx = 0; while (current != NULL) { printf(\u0026#34;idx %d: (%d, %d)\\n\u0026#34;, idx, current-\u0026gt;data.x, current-\u0026gt;data.y); idx++; current = current-\u0026gt;next; } } // END HELPER STUFF void read_array(int *array, char *path) { // open the input file FILE *fp = fopen(path, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;Failed to open file \\n\u0026#34;); } int count = 0; // read the integers from the file into the array for (int i = 0; i \u0026lt; ROWS; i++) { for (int j = 0; j \u0026lt; COLS; j++) { int cur; if (!fscanf(fp, \u0026#34;%d\u0026#34;, \u0026amp;cur)) { printf(\u0026#34;FAIL\u0026#34;); } count++; array[i * COLS + j] = cur; } } // close the input file fclose(fp); printf(\u0026#34;count: %d\\n\u0026#34;, count); } void generate_hooks_with_size(struct Tuple *xy) // generates points along a circle { double r = (WHEEL_PIXEL_SIZE / 2.0) - 1.0; double *theta = (double *)malloc((N_HOOKS) * sizeof(double)); double epsilon = asin(HOOK_PIXEL_SIZE / WHEEL_PIXEL_SIZE); for (int i = 0; i \u0026lt; (N_HOOKS \u0026gt;\u0026gt; 1); i++) { double angle = (double)i / (double)(N_HOOKS \u0026gt;\u0026gt; 1) * (2.0 * M_PI); theta[i * 2] = angle - epsilon; theta[i * 2 + 1] = angle + epsilon; } for (int j = 0; j \u0026lt; N_HOOKS; j++) { struct Tuple point; point.x = r * (1.0 + cos(theta[j])) + 0.5; point.y = r * (1.0 + sin(theta[j])) + 0.5; xy[j] = point; } free(theta); } void through_pixels(struct Tuple p0, struct Tuple p1, struct LinkedList *pixels) { int x0 = p0.x; int y0 = p0.y; int x1 = p1.x; int y1 = p1.y; int dx = abs(x1 - x0); int dy = abs(y1 - y0); int sx = (x0 \u0026lt; x1) ? 1 : -1; int sy = (y0 \u0026lt; y1) ? 1 : -1; int err = dx - dy; while (1) { struct Tuple point; point.x = x0; point.y = y0; append(pixels, point); if (x0 == x1 \u0026amp;\u0026amp; y0 == y1) { return; } int e2 = 2 * err; if (e2 \u0026gt; -dy) { err -= dy; x0 += sx; } if (e2 \u0026lt; dx) { err += dx; y0 += sy; } else if (e2 == dx) { // Handle cases with slope 1 or -1 err -= dy; x0 += sx; err += dx; y0 += sy; } } } // takes image assuming it has been preprocessed for weights int calculate_penalty(int cur, int weight) { if (cur \u0026lt; 0) { // // DEBUG______________________________ // return (weight \u0026lt; 0) ? 0 : ((int)(-cur * 0.25) \u0026gt;\u0026gt; weight); // // DEBUG______________________________ return (weight \u0026lt; 0) ? 0 : -((cur \u0026gt;\u0026gt; LIGHTNESS_PENALTY) \u0026gt;\u0026gt; weight); } else { return (weight \u0026lt; 0) ? 0 : (cur \u0026gt;\u0026gt; weight); } } void generate_unique_random_numbers(int min, int max, int exclude, int N, int *result) { int range = max - min + 1; int adjusted_range = range - (exclude \u0026gt;= min \u0026amp;\u0026amp; exclude \u0026lt;= max); if (N \u0026gt; adjusted_range) { printf(\u0026#34;Error: Cannot generate %d unique random numbers in the given range.\\n\u0026#34;, N); return; } int *flags = (int *)calloc(range, sizeof(int)); flags[exclude - min] = 1; for (int i = 0; i \u0026lt; N; i++) { int rand_num; do { rand_num = rand() % range + min; } while (flags[rand_num - min]); flags[rand_num - min] = 1; result[i] = rand_num; } free(flags); } void optimise_fitness(int *image, int *weight, int *previous_edge, struct Tuple *xy) { int starting_edge = *previous_edge; int count = 0; // randomly chose a subset of endpoints int *chosen = (int *)malloc(TIME_SAVER * sizeof(int)); generate_unique_random_numbers(0, N_HOOKS - 1, starting_edge, TIME_SAVER, chosen); // // DEBUG______________________________ // for (int ii = 0; ii \u0026lt; TIME_SAVER; ii ++){ // printf(\u0026#34;el %d: %d \\n\u0026#34;, ii, chosen[ii]); // } // // DEBUG______________________________ int best_endpoint = -1; int best_reduction = INT_MIN; for (int i = 0; i \u0026lt; TIME_SAVER; i++) { int ending_edge = chosen[i]; struct LinkedList *pixels = initLinkedList(); int penalty_without = 0; int penalty_with = 0; int reduction; through_pixels(xy[starting_edge], xy[ending_edge], pixels); int norm = 0; struct Node *current = pixels-\u0026gt;head; while (current != NULL) { norm++; struct Node *temp = current; int image_data = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; int weight_data; if (temp-\u0026gt;data.y % 2 == 0) { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS]; } else { weight_data = weight[temp-\u0026gt;data.x + (temp-\u0026gt;data.y - 1) * COLS]; } int cur_penalty_without = calculate_penalty(image_data, weight_data); int cur_penalty_with = calculate_penalty(image_data - DARKNESS, weight_data); penalty_with = cur_penalty_with + penalty_with; penalty_without = cur_penalty_without + penalty_without; current = current-\u0026gt;next; free(temp); } free(pixels); reduction = (penalty_without - penalty_with) / norm; if (reduction \u0026gt; best_reduction) { best_reduction = reduction; best_endpoint = ending_edge; } } free(chosen); *previous_edge = best_endpoint; } void update_image(int *image, struct Tuple *xy, int start, int end) { struct LinkedList *pixels = initLinkedList(); through_pixels(xy[start], xy[end], pixels); struct Node *current = pixels-\u0026gt;head; while (current != NULL) { struct Node *temp = current; image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] = image[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS] - DARKNESS; current = current-\u0026gt;next; free(temp); } free(pixels); } void find_lines(int *image, int *weight, struct Tuple *xy, struct Tuple *line_list) { int next_edge_value = rand() % N_HOOKS; int *next_edge = \u0026amp;next_edge_value; for (int i = 0; i \u0026lt; N_LINES; i++) { int previous_edge = *next_edge; optimise_fitness(image, weight, next_edge, xy); update_image(image, xy, previous_edge, *next_edge); line_list[i * 2] = xy[previous_edge]; line_list[i * 2 + 1] = xy[*next_edge]; } } void p_t(struct Tuple point) { printf(\u0026#34;%d, %d\u0026#34;, point.x, point.y); } int main() { // static seed for testing srand(42); clock_t start, end; double cpu_time_used; start = clock(); printf(\u0026#34;Generating Hooks\\n\u0026#34;); struct Tuple *xy = (struct Tuple *)malloc(N_HOOKS * sizeof(struct Tuple)); generate_hooks_with_size(xy); printf(\u0026#34;Reading Image Data\\n\u0026#34;); int *ah_monochrome = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_monochrome, \u0026#34;monalisa.txt\u0026#34;); printf(\u0026#34;Reading Weight Data\\n\u0026#34;); int *ah_weights = malloc((ROWS * COLS) * sizeof(int)); read_array(ah_weights, \u0026#34;ah_wpos.txt\u0026#34;); // COMMENT WHEN USING WEIGHTS // for (int j = 0; j \u0026lt; ROWS; j++){ // for (int k = 0; k \u0026lt; COLS; k++){ // ah_weights[j*COLS+k] = 0; // } // } printf(\u0026#34;Allocating connections list and running optimizer\\n\u0026#34;); struct Tuple *line_list = (struct Tuple *)malloc(N_LINES * sizeof(struct Tuple) * 2); find_lines(ah_monochrome, ah_weights, xy, line_list); // Open the file for writing printf(\u0026#34;Done, writing output file\\n\u0026#34;); FILE *file = fopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening the file.\\n\u0026#34;); return 1; } // Write the array elements to the file for (int i = 0; i \u0026lt; N_LINES; i++) { fprintf(file, \u0026#34;%d\u0026#34;, line_list[i * 2].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2].y); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].x); fprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].y); // Use a newline character instead of a comma to separate elements if (i \u0026lt; N_LINES - 1) { fprintf(file, \u0026#34;\\n\u0026#34;); } } // Close the file fclose(file); printf(\u0026#34;Array written to the output.txt file.\\n\u0026#34;); free(line_list); free(xy); free(ah_monochrome); free(ah_weights); end = clock(); cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC; printf(\u0026#34;Memory freed, used %f CPU time\\n\u0026#34;, cpu_time_used); return 0; } "},{"id":4,"href":"/docs/appendix/commented-code/hps/","title":"Hps","section":"Commented Code","content":"///////////////////////////////////////\r/// 640x480 version! 16-bit color\r/// This code will segfault the original\r/// DE1 computer\r/// compile with\r/// gcc graphics_video_16bit.c -o gr -O2 -lm\r/// gcc fpga_thread_art.c -o gr -O2 -lm -std=c99 -pthread\r///////////////////////////////////////\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;stdlib.h\u0026gt;\r#include \u0026lt;unistd.h\u0026gt;\r#include \u0026lt;fcntl.h\u0026gt;\r#include \u0026lt;sys/types.h\u0026gt;\r#include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt;\r#include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;math.h\u0026gt;\r#include \u0026lt;stdint.h\u0026gt;\r#include \u0026lt;pthread.h\u0026gt;\r// #include \u0026#34;address_map_arm_brl4.h\u0026#34;\r// video display\r#define SDRAM_BASE 0xC0000000\r#define SDRAM_END 0xC3FFFFFF\r#define SDRAM_SPAN\t0x04000000\r// characters\r#define FPGA_CHAR_BASE 0xC9000000 #define FPGA_CHAR_END 0xC9001FFF\r#define FPGA_CHAR_SPAN 0x00002000\r/* Cyclone V FPGA devices */\r#define HW_REGS_BASE 0xff200000\r//#define HW_REGS_SPAN 0x00200000 #define HW_REGS_SPAN 0x00005000\r// PIO BASE ADDRESSES\r#define ARM_DATA_BASE 0x00000000\r#define ARM_VAL_BASE 0x00000010\r#define ARM_RDY_BASE 0x00000020\r#define FPGA_DATA_BASE 0x00000030\r#define FPGA_VAL_BASE 0x00000040\r#define FPGA_RDY_BASE 0x00000050\r#define PIO_RESET_BASE 0x00000060\r#define ARM_ACK_BASE 0x00000070\r#define FPGA_ACK_BASE 0x00000080\r#define ARM_DATA2_BASE 0x00000090\r// IMAGE CONSTANTS\r#define WHEEL_PIXEL_SIZE 480\r#define N_HOOKS 160 // needs to be divisible by 2\r#define HOOK_PIXEL_SIZE 3\r#define ROWS 480\r#define COLS 480\r#define N_LINES 360\r#define SPACE_SAVER 40 // defined as terms to actually consider\r#ifndef M_PI\r#define M_PI 3.14159265358979323846\r#endif\r#ifndef INT_MIN\r#define INT_MIN -2147483648\r#endif\r#define DARKNESS 150\r// PIO POINTERS\rvolatile unsigned int * arm_data_ptr = NULL;\rvolatile unsigned int * arm_data2_ptr = NULL;\rvolatile unsigned int * arm_val_ptr = NULL;\rvolatile unsigned int * arm_rdy_ptr = NULL;\rvolatile unsigned int * fpga_data_ptr = NULL;\rvolatile unsigned int * fpga_val_ptr = NULL;\rvolatile unsigned int * fpga_rdy_ptr = NULL;\rvolatile unsigned int * pio_reset_ptr = NULL;\rvolatile unsigned int * arm_ack_ptr = NULL;\rvolatile unsigned int * fpga_ack_ptr = NULL;\r// HELPER STUFF\rstruct Tuple {\rint x;\rint y;\r};\rstruct Node {\rstruct Tuple data;\rstruct Node *next;\r};\rstruct LinkedList {\rstruct Node *head;\rstruct Node *tail;\r};\rstruct LinkedList *initLinkedList() {\rstruct LinkedList *list = (struct LinkedList *)malloc(sizeof(struct LinkedList));\rlist-\u0026gt;head = NULL;\rlist-\u0026gt;tail = NULL;\rreturn list;\r}\rvoid freeList(struct LinkedList *list) {\rstruct Node *current = list-\u0026gt;head;\rwhile (current != NULL)\r{\rstruct Node *temp = current;\rcurrent = current-\u0026gt;next;\rfree(temp);\r}\rfree(list);\r}\rvoid append(struct LinkedList *list, struct Tuple data) {\r// allocate memory for the new node\rstruct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\r// set the data of the new node\rnew_node-\u0026gt;data = data;\r// set the next pointer of the new node to NULL\rnew_node-\u0026gt;next = NULL;\r// if the list is empty, set the new node as the head and tail of the list\rif (list-\u0026gt;head == NULL)\r{\rlist-\u0026gt;head = new_node;\rlist-\u0026gt;tail = new_node;\r}\r// otherwise, append the new node to the tail of the list\relse\r{\rlist-\u0026gt;tail-\u0026gt;next = new_node;\rlist-\u0026gt;tail = new_node;\r}\r}\rvoid through_pixels(struct Tuple p0, struct Tuple p1, struct LinkedList *pixels)\r{\rint x0 = p0.x;\rint y0 = p0.y;\rint x1 = p1.x;\rint y1 = p1.y;\rint dx = abs(x1 - x0);\rint dy = abs(y1 - y0);\rint sx = (x0 \u0026lt; x1) ? 1 : -1;\rint sy = (y0 \u0026lt; y1) ? 1 : -1;\rint err = dx - dy;\rwhile (1)\r{\rstruct Tuple point;\rpoint.x = x0;\rpoint.y = y0;\rappend(pixels, point);\rif (x0 == x1 \u0026amp;\u0026amp; y0 == y1)\r{\rreturn;\r}\rint e2 = 2 * err;\rif (e2 \u0026gt; -dy)\r{\rerr -= dy;\rx0 += sx;\r}\rif (e2 \u0026lt; dx)\r{\rerr += dx;\ry0 += sy;\r}\relse if (e2 == dx)\r{ // Handle cases with slope 1 or -1\rerr -= dy;\rx0 += sx;\rerr += dx;\ry0 += sy;\r}\r}\r}\rvoid generate_hooks_with_size(struct Tuple *xy)\r{\rdouble r = (WHEEL_PIXEL_SIZE / 2.0) - 1.0;\rdouble *theta = (double *)malloc((N_HOOKS) * sizeof(double));\rdouble epsilon = asin(HOOK_PIXEL_SIZE / WHEEL_PIXEL_SIZE);\rfor (int i = 0; i \u0026lt; (N_HOOKS \u0026gt;\u0026gt; 1); i++)\r{\rdouble angle = (double)i / (double)(N_HOOKS \u0026gt;\u0026gt; 1) * (2.0 * M_PI);\rtheta[i * 2] = angle - epsilon;\rtheta[i * 2 + 1] = angle + epsilon;\r}\rfor (int j = 0; j \u0026lt; N_HOOKS; j++)\r{\rstruct Tuple point;\rpoint.x = r * (1.0 + cos(theta[j])) + 0.5;\rpoint.y = r * (1.0 + sin(theta[j])) + 0.5;\rxy[j] = point;\r}\rfree(theta);\r}\rvoid generate_unique_random_numbers(int min, int max, int exclude, int N, int *result)\r{\rint range = max - min + 1;\rint adjusted_range = range - (exclude \u0026gt;= min \u0026amp;\u0026amp; exclude \u0026lt;= max);\rif (N \u0026gt; adjusted_range)\r{\rprintf(\u0026#34;Error: Cannot generate %d unique random numbers in the given range.\\n\u0026#34;, N);\rreturn;\r}\rint *flags = (int *)calloc(range, sizeof(int));\rflags[exclude - min] = 1;\rfor (int i = 0; i \u0026lt; N; i++)\r{\rint rand_num;\rdo\r{\rrand_num = rand() % range + min;\r} while (flags[rand_num - min]);\rflags[rand_num - min] = 1;\rresult[i] = rand_num;\r}\rfree(flags);\r}\r// NEW STUFF\rvoid read_array(int *array, char *path) {\r// open the input file\rFILE *fp = fopen(path, \u0026#34;r\u0026#34;);\rif (fp == NULL)\r{\rprintf(\u0026#34;Failed to open file \\n\u0026#34;);\r}\rint count = 0;\r// read the integers from the file into the array\rfor (int i = 0; i \u0026lt; ROWS; i++)\r{\rfor (int j = 0; j \u0026lt; COLS; j++)\r{\rint cur;\rif (!fscanf(fp, \u0026#34;%d\u0026#34;, \u0026amp;cur))\r{\rprintf(\u0026#34;FAIL\u0026#34;);\r}\rcount++;\rarray[i * COLS + j] = cur;\r}\r}\r// close the input file\rfclose(fp);\rprintf(\u0026#34;count: %d\\n\u0026#34;, count);\r}\rvoid *RESET()\r{ // Reset Thread\rfor (;;)\r{\rif (*(pio_reset_ptr))\r{\r*(arm_val_ptr) = 0;\r*(arm_rdy_ptr) = 0;\r*(arm_data_ptr) = 0;\r*(arm_data2_ptr) = 0;\r*(arm_ack_ptr) = 0;\r// printf(\u0026#34;RESET HIT\\n\u0026#34;);\r}\r}\r}\rvoid *SERVICE_VERIFY(){\rint *ah_monochrome = malloc((ROWS * COLS) * sizeof(int));\rread_array(ah_monochrome, \u0026#34;ah_monochrome.txt\u0026#34;);\rint count = 0;\rint mismatch_count = 0;\rfor (int i = 0; i \u0026lt; ROWS; i++)\r{\rfor (int j = 0; j \u0026lt; COLS; j++)\r{\r*(arm_ack_ptr) = 0;\r*(arm_rdy_ptr) = 1;\rwhile ( ! *(fpga_val_ptr)) { // wait for valid data from FPGA\rprintf(\u0026#34;hit\\n\u0026#34;);\r}\r// while (*(fpga_val_ptr))\r// { // wait for valid data from FPGA\r// }\r*(arm_rdy_ptr) = 0;\r// printf(\u0026#34;got: %d, expected: %d \\n\u0026#34;, *(fpga_data_ptr), ah_monochrome[i * COLS + j]);\r// printf(\u0026#34;count: %d\\n\u0026#34;, count);\ruint32_t both = *(fpga_data_ptr);\ruint32_t top = both \u0026gt;\u0026gt; 5;\ruint32_t bottom = both \u0026amp; 0x00001F; //9 bits\rif (top != ah_monochrome[i * COLS + j]){\r// mismatch_count ++;\r// printf(\u0026#34;expected top: %d, got: %d\\n\u0026#34;, ah_monochrome[(i + 1) * COLS + j], bottom);\r}\rif (bottom != ah_monochrome[i*COLS + j]){\r// mismatch_count ++;\r// printf(\u0026#34;expected bottom: %d, got: %d\\n\u0026#34;, ah_monochrome[(i+1)*COLS + j], bottom);\r}\rcount ++;\r// *(arm_ack_ptr) = 1; // ack the data\r// while (! *(fpga_ack_ptr)) { // wait for FPGA to read ack\r// }\r// *(arm_ack_ptr) = 0; // reset ack\r// while (*(fpga_ack_ptr )){ // wait for FPGA to reset ack\r// }\r}\r}\rprintf(\u0026#34;MISMATCHES: %d\\n\u0026#34;, mismatch_count);\rfree(ah_monochrome);\r}\rvoid *SERVICE_WRITE()\r{\rint *ah_monochrome = malloc((ROWS * COLS) * sizeof(int));\rread_array(ah_monochrome, \u0026#34;ah_monochrome.txt\u0026#34;);\rint count = 0;\rfor (int i = 0; i \u0026lt; ROWS; i++)\r{\rfor (int j = 0; j \u0026lt; COLS; j++)\r{\r// printf(\u0026#34;count: %d\\n\u0026#34;, count);\r*(arm_val_ptr) = 0;\ruint16_t cur = (uint16_t)ah_monochrome[i * COLS + j] / 2;\ruint32_t is_last = (i == ROWS - 1 \u0026amp;\u0026amp; j == COLS - 1) \u0026lt;\u0026lt; 31;\ruint32_t mask = ~(1 \u0026lt;\u0026lt; 31); // Bitmask with all bits set to 1, except bit 31\ruint32_t combined;\rcombined = ((uint32_t)cur) \u0026amp; mask;\rcombined = combined | is_last;\r*(arm_data_ptr) = combined;\rcount++;\r*(arm_val_ptr) = 1; // try to transfer\r// while ( !*(fpga_ack_ptr) ) { // wait for fpga to ack\r// }\rwhile (!*(fpga_rdy_ptr))\r{ // wait for fpga to ack\rprintf(\u0026#34;waiting for fpga to ack\\n\u0026#34;);\r}\r*(arm_val_ptr) = 0; // clear our val\r// once acked, send clear flag, through the form of return ack\r// *(arm_ack_ptr) = 1;\r// while ( *(fpga_ack_ptr) ) { // wait for fpga to clear ack\r// }\r// while ( *(fpga_rdy_ptr) ) { // wait for fpga to clear ack\r// printf(\u0026#34;fdsf\\n\u0026#34;);\r// }\r// printf(\u0026#34;count: %d\\n\u0026#34;, count);\r// *(arm_ack_ptr) = 0; // clear our ack and move onto next transfer\r}\r}\rprintf(\u0026#34;DONE WRITING MEM\\n\u0026#34;);\rfree(ah_monochrome);\r}\r// TOP OF SERVICE_CALC\rvoid *SERVICE_CALC() {\rclock_t start, end;\rdouble cpu_time_used;\rstart = clock();\rsrand(42);\rint *ah_monochrome = malloc((ROWS * COLS) * sizeof(int));\rread_array(ah_monochrome, \u0026#34;ah_monochrome.txt\u0026#34;);\r*(arm_val_ptr) = 0; // sanity check\r*(arm_ack_ptr) = 0; // sanity check\rstruct Tuple *line_list = (struct Tuple *)malloc(N_LINES * sizeof(struct Tuple) * 2);\rstruct Tuple *xy = (struct Tuple *)malloc(N_HOOKS * sizeof(struct Tuple));\rgenerate_hooks_with_size(xy);\rint prev_edge = rand() % N_HOOKS;\rfor (int i = 0; i \u0026lt; N_LINES; i++){\rint starting_edge = prev_edge;\rint *chosen = (int *)malloc(SPACE_SAVER * sizeof(int));\rgenerate_unique_random_numbers(0, N_HOOKS - 1, starting_edge, SPACE_SAVER, chosen);\r// have the randomly chosen indices to consider, transfer to fpga\r// FIRST TRANSFER THE STARTING POINT===============================\r*(arm_val_ptr) = 0;\ruint32_t combined;\ruint16_t x = (uint16_t)xy[starting_edge].x;\ruint16_t y = (uint16_t)xy[starting_edge].y;\r// printf(\u0026#34;starting x: %d, starting y: %d\\n\u0026#34;, x, y);\r// uint16_t x = 0;\r// uint16_t y = 0;\rcombined = ((uint32_t) y \u0026lt;\u0026lt; 9 ) | x; *(fpga_data_ptr) = combined;\r*(arm_val_ptr) = 1; // try to transfer\rwhile (!*(fpga_ack_ptr))\r{ // wait for fpga to ack\r// printf(\u0026#34; FUCKING SPINNING\\n\u0026#34;);\r}\r*(arm_val_ptr) = 0; // clear our val\r// once acked, send clear flag, through the form of return ack\r*(arm_ack_ptr) = 1;\rwhile (*(fpga_ack_ptr))\r{ // wait for fpga to clear ack\r// printf(\u0026#34;STUCK HERE\\n\u0026#34;);\r}\r*(arm_ack_ptr) = 0; // clear our ack and move onto next transfer\r// FIRST TRANSFER THE STARTING POINT===============================\rfor (int j = 0; j \u0026lt; SPACE_SAVER - 1; j++){ // TRANSFER THE ENDPOINTS, (starting point takes up one position)\r*(arm_val_ptr) = 0;\rint ending_edge = chosen[j];\ruint32_t is_last_chosen = j == SPACE_SAVER - 2;\ruint32_t mask = ~(1 \u0026lt;\u0026lt; 31); // Bitmask with all bits set to 1, except bit 31\ruint32_t combined;\ruint16_t x = (uint16_t)xy[ending_edge].x;\ruint16_t y = (uint16_t)xy[ending_edge].y;\rcombined = (((uint32_t)y \u0026lt;\u0026lt; 9) | x ) \u0026amp; mask;\rcombined = combined | (is_last_chosen \u0026lt;\u0026lt; 31);\r*(fpga_data_ptr) = combined;\r*(arm_val_ptr) = 1; // try to transfer\rwhile (!*(fpga_ack_ptr))\r{ // wait for fpga to ack\rprintf(\u0026#34;STUCK HERE1\\n\u0026#34;);\r}\r*(arm_val_ptr) = 0; // clear our val\r// once acked, send clear flag, through the form of return ack\r*(arm_ack_ptr) = 1;\rwhile (*(fpga_ack_ptr))\r{ // wait for fpga to clear ack\rprintf(\u0026#34;STUCK HERE2\\n\u0026#34;);\r}\r*(arm_ack_ptr) = 0; // clear our ack and move onto next transfer\r}\r// values have been transferred, now wait for fpga to calculate\r// printf(\u0026#34; VALUES TRANSFERRED \\n\u0026#34;);\r*(arm_ack_ptr) = 0; // sanity check\r// printf(\u0026#34;fpga_val_ptr: %d\\n\u0026#34;, *(fpga_val_ptr));\rint *norms = (int *)malloc(SPACE_SAVER * sizeof(int));\rint *reductions = (int *)malloc(SPACE_SAVER * sizeof(int));\rfor (int k = 0; k \u0026lt; SPACE_SAVER; k++){\r// printf(\u0026#34;K is at %d\\n\u0026#34;, k);\r*(arm_ack_ptr) = 0; // sanity check\rwhile (!*(fpga_val_ptr))\r{ // wait for valid data from FPGA\r// printf(\u0026#34;STUCK HERE3\\n\u0026#34;);\r}\rint norm = *(fpga_data_ptr) \u0026gt;\u0026gt; 16;\rint reduction = *(fpga_data_ptr) \u0026amp; 0xFFFF;\r// printf(\u0026#34; got norm: %d, reduction: %d \\n\u0026#34;, norm, reduction);\rnorms[k] = norm;\rreductions[k] = reduction;\r*(arm_ack_ptr) = 1; // ack the data\rwhile (!*(fpga_ack_ptr))\r{ // wait for FPGA to read ack\rprintf(\u0026#34;STUCK HERE4\\n\u0026#34;);\r}\r*(arm_ack_ptr) = 0; // reset ack\rwhile (*(fpga_ack_ptr))\r{ // wait for FPGA to reset ack\rprintf(\u0026#34;STUCK HERE5\\n\u0026#34;);\r}\r}\r// for (int kk = 0; kk \u0026lt; SPACE_SAVER; kk++){\r// // printf(\u0026#34;norms[%d]: %d\\n\u0026#34;, kk, norms[kk]);\r// // printf(\u0026#34;reductions[%d]: %d\\n\u0026#34;, kk, reductions[kk]);\r// }\r// get the best value\rint best_reduction = INT_MIN;\rint chosen_edge = -1;\rfor (int l = 0; l \u0026lt; SPACE_SAVER; l++){\rfloat true = (float) reductions[l] / (float) norms[l];\r// printf(\u0026#34;(true: %f %d %d %d %d\\n\u0026#34;, true, xy[starting_edge].x, xy[starting_edge].y, xy[chosen[l]].x, xy[chosen[l]].y);\rif (true \u0026gt; best_reduction){\rbest_reduction = true;\rchosen_edge = l;\r}\r}\rfree(norms);\rfree(reductions);\rfree(chosen);\r// add the chosen edge to the list\rline_list[i * 2] = xy[starting_edge];\rline_list[i * 2 + 1] = xy[chosen_edge];\rprev_edge = chosen_edge;\r// printf(\u0026#34;(%d %d %d %d)\\n\u0026#34;, xy[starting_edge].x, xy[starting_edge].y, xy[chosen_edge].x, xy[chosen_edge].y);\r// update the values and write values back to FPGA\r*(arm_val_ptr) = 0; // sanity check\rstruct Tuple p0 = xy[starting_edge];\rstruct Tuple p1 = xy[chosen_edge];\rstruct LinkedList* pixels = initLinkedList();\rthrough_pixels(p0, p1, pixels);\rstruct Node * current = pixels-\u0026gt;head;\r// printf(\u0026#34;STARTING WRITEBACK\\n\u0026#34;);\rwhile (current != NULL) {\rstruct Node *temp = current;\rint is_last = current-\u0026gt;next == NULL;\r// printf(\u0026#34;is_last: %d\\n\u0026#34;, is_last);\ruint32_t mask = ~(1 \u0026lt;\u0026lt; 31); // Bitmask with all bits set to 1, except bit 31\r*(arm_val_ptr) = 0; // sanity check\rint other_value;\rint cur_image_value = ah_monochrome[temp-\u0026gt;data.x + (temp-\u0026gt;data.y) * COLS ];\rint new_image_value = cur_image_value - DARKNESS;\rint which_mem = temp-\u0026gt;data.y \u0026gt;\u0026gt; 1; // divide by 2\rint addr = temp-\u0026gt;data.x;\r// construct the combined value\ruint32_t combined;\ruint32_t combined_address;\rif (temp-\u0026gt;data.y % 2 == 0) { // if value is even we have the upper value already, need lower value\tother_value = ah_monochrome[temp-\u0026gt;data.x + (temp-\u0026gt;data.y + 1) * COLS ];\rcombined = (((uint32_t)other_value \u0026lt;\u0026lt; 10) | new_image_value);\r}\relse {\rother_value = ah_monochrome[temp-\u0026gt;data.x + (temp-\u0026gt;data.y - 1) * COLS ];\rcombined = (((uint32_t)new_image_value \u0026lt;\u0026lt; 10) | other_value);\r}\rcombined_address = ((uint32_t)which_mem \u0026lt;\u0026lt; 16) | addr;\rcombined_address = combined_address \u0026amp; mask;\rcombined_address = combined_address | (is_last \u0026lt;\u0026lt; 31);\rcombined = combined \u0026amp; mask;\rcombined = combined | (is_last \u0026lt;\u0026lt; 31);\r*(arm_data_ptr) = combined;\r*(arm_data2_ptr) = combined_address;\r*(arm_val_ptr) = 1; // try to transfer\rwhile (!*(fpga_ack_ptr))\r{ // wait for fpga to ack\r// printf(\u0026#34;STUCK HERE6\\n\u0026#34;);\r}\r*(arm_val_ptr) = 0; // clear our val\r// once acked, send clear flag, through the form of return ack\r*(arm_ack_ptr) = 1;\rwhile (*(fpga_ack_ptr))\r{ // wait for fpga to clear ack\r// printf(\u0026#34;STUCK HERE7\\n\u0026#34;);\r}\r*(arm_ack_ptr) = 0; // clear our ack and move onto next transfer\rcurrent = current-\u0026gt;next;\rfree(temp);\r}\rfree(pixels);\r}\rprintf(\u0026#34;DONE WITH EVERYTHING\\n\u0026#34;);\r// Open the file for writing\rprintf(\u0026#34;WRITING OUTPUT FILE\\n\u0026#34;);\rFILE *file = fopen(\u0026#34;fpga_output.txt\u0026#34;, \u0026#34;w\u0026#34;);\rif (file == NULL)\r{\rprintf(\u0026#34;Error opening the file.\\n\u0026#34;);\r// return 1;\r}\r// Write the array elements to the file\rfor (int i = 0; i \u0026lt; N_LINES; i++)\r{\rfprintf(file, \u0026#34;%d\u0026#34;, line_list[i * 2].x);\rfprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2].y);\rfprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].x);\rfprintf(file, \u0026#34; %d\u0026#34;, line_list[i * 2 + 1].y);\r// Use a newline character instead of a comma to separate elements\rif (i \u0026lt; N_LINES - 1)\r{\rfprintf(file, \u0026#34;\\n\u0026#34;);\r}\r}\r// Close the file\rfclose(file);\rprintf(\u0026#34;DONE WRITING\\n\u0026#34;);\rfree(xy);\rfree(line_list);\rfree(ah_monochrome);\rend = clock();\rcpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;\r} // BOTTOM OF SERVICE_CALC\r// graphics primitives\rvoid VGA_text (int, int, char *);\rvoid VGA_text_clear();\rvoid VGA_box (int, int, int, int, short);\rvoid VGA_rect (int, int, int, int, short);\rvoid VGA_line(int, int, int, int, short) ;\rvoid VGA_Vline(int, int, int, short) ;\rvoid VGA_Hline(int, int, int, short) ;\rvoid VGA_disc (int, int, int, short);\rvoid VGA_circle (int, int, int, int);\r// 16-bit primary colors\r#define red (0+(0\u0026lt;\u0026lt;5)+(31\u0026lt;\u0026lt;11))\r#define dark_red (0+(0\u0026lt;\u0026lt;5)+(15\u0026lt;\u0026lt;11))\r#define green (0+(63\u0026lt;\u0026lt;5)+(0\u0026lt;\u0026lt;11))\r#define dark_green (0+(31\u0026lt;\u0026lt;5)+(0\u0026lt;\u0026lt;11))\r#define blue (31+(0\u0026lt;\u0026lt;5)+(0\u0026lt;\u0026lt;11))\r#define dark_blue (15+(0\u0026lt;\u0026lt;5)+(0\u0026lt;\u0026lt;11))\r#define yellow (0+(63\u0026lt;\u0026lt;5)+(31\u0026lt;\u0026lt;11))\r#define cyan (31+(63\u0026lt;\u0026lt;5)+(0\u0026lt;\u0026lt;11))\r#define magenta (31+(0\u0026lt;\u0026lt;5)+(31\u0026lt;\u0026lt;11))\r#define black (0x0000)\r#define gray (15+(31\u0026lt;\u0026lt;5)+(51\u0026lt;\u0026lt;11))\r#define white (0xffff)\rint colors[] = {red, dark_red, green, dark_green, blue, dark_blue, yellow, cyan, magenta, gray, black, white};\r// pixel macro\r#define VGA_PIXEL(x,y,color) do{\\\rint *pixel_ptr ;\\\rpixel_ptr = (int*)((char *)vga_pixel_ptr + (((y)*640+(x))\u0026lt;\u0026lt;1)) ; \\\r*(short *)pixel_ptr = (color);\\\r} while(0)\r// the light weight buss base\rvoid *h2p_lw_virtual_base;\r// pixel buffer\rvolatile unsigned int * vga_pixel_ptr = NULL ;\rvoid *vga_pixel_virtual_base;\r// character buffer\rvolatile unsigned int * vga_char_ptr = NULL ;\rvoid *vga_char_virtual_base;\r// /dev/mem file id\rint fd;\r// measure time\rstruct timeval t1, t2;\rdouble elapsedTime;\rint main(void)\r{\r// === need to mmap: =======================\r// FPGA_CHAR_BASE\r// FPGA_ONCHIP_BASE // HW_REGS_BASE // === get FPGA addresses ==================\r// Open /dev/mem\rif( ( fd = open( \u0026#34;/dev/mem\u0026#34;, ( O_RDWR | O_SYNC ) ) ) == -1 ) {\rprintf( \u0026#34;ERROR: could not open \\\u0026#34;/dev/mem\\\u0026#34;...\\n\u0026#34; );\rreturn( 1 );\r}\r// get virtual addr that maps to physical\rh2p_lw_virtual_base = mmap( NULL, HW_REGS_SPAN, ( PROT_READ | PROT_WRITE ), MAP_SHARED, fd, HW_REGS_BASE );\tif( h2p_lw_virtual_base == MAP_FAILED ) {\rprintf( \u0026#34;ERROR: mmap1() failed...\\n\u0026#34; );\rclose( fd );\rreturn(1);\r}\r// map PIO\rarm_data_ptr =(unsigned int *)(h2p_lw_virtual_base + ARM_DATA_BASE);\rarm_data2_ptr = (unsigned int *)(h2p_lw_virtual_base + ARM_DATA2_BASE);\rarm_val_ptr =(unsigned int *)(h2p_lw_virtual_base + ARM_VAL_BASE);\rarm_rdy_ptr =(unsigned int *)(h2p_lw_virtual_base + ARM_RDY_BASE);\rfpga_data_ptr =(unsigned int *)(h2p_lw_virtual_base + FPGA_DATA_BASE);\rfpga_val_ptr =(unsigned int *)(h2p_lw_virtual_base + FPGA_VAL_BASE);\rfpga_rdy_ptr =(unsigned int *)(h2p_lw_virtual_base + FPGA_RDY_BASE);\rpio_reset_ptr =(unsigned int *)(h2p_lw_virtual_base + PIO_RESET_BASE);\rarm_ack_ptr = (unsigned int *)(h2p_lw_virtual_base + ARM_ACK_BASE);\rfpga_ack_ptr = (unsigned int *)(h2p_lw_virtual_base + FPGA_ACK_BASE);\r// === get VGA char addr =====================\r// get virtual addr that maps to physical\rvga_char_virtual_base = mmap( NULL, FPGA_CHAR_SPAN, ( PROT_READ | PROT_WRITE ), MAP_SHARED, fd, FPGA_CHAR_BASE );\tif( vga_char_virtual_base == MAP_FAILED ) {\rprintf( \u0026#34;ERROR: mmap2() failed...\\n\u0026#34; );\rclose( fd );\rreturn(1);\r}\r// Get the address that maps to the FPGA LED control vga_char_ptr =(unsigned int *)(vga_char_virtual_base);\r// === get VGA pixel addr ====================\r// get virtual addr that maps to physical\rvga_pixel_virtual_base = mmap( NULL, SDRAM_SPAN, ( PROT_READ | PROT_WRITE ), MAP_SHARED, fd, SDRAM_BASE);\tif( vga_pixel_virtual_base == MAP_FAILED ) {\rprintf( \u0026#34;ERROR: mmap3() failed...\\n\u0026#34; );\rclose( fd );\rreturn(1);\r}\r// Get the address that maps to the FPGA pixel buffer\rvga_pixel_ptr =(unsigned int *)(vga_pixel_virtual_base);\r// ===========================================\r/* create a message to be displayed on the VGA and LCD displays */\r// position of disk primitive\rint disc_x = 0;\r// position of circle primitive\rint circle_x = 0 ;\r// position of box primitive\rint box_x = 5 ;\r// position of vertical line primitive\rint Vline_x = 350;\r// position of horizontal line primitive\rint Hline_y = 250;\r// clear the screen\rVGA_box (0, 0, 639, 479, 0x0000);\r// clear the text\rVGA_text_clear();\r// R bits 11-15 mask 0xf800\r// G bits 5-10 mask 0x07e0\r// B bits 0-4 mask 0x001f\r// so color = B+(G\u0026lt;\u0026lt;5)+(R\u0026lt;\u0026lt;11);\rpthread_t thread_reset;\rpthread_create(\u0026amp;thread_reset, NULL, RESET, NULL);\rwhile(1) {\r*(arm_val_ptr) = 0;\r*(arm_rdy_ptr) = 0;\r*(arm_data_ptr) = 0;\r*(arm_ack_ptr) = 0;\rprintf(\u0026#34;press w to write FPGA memory, v to verify FPGA memory, c to calculate \\n\u0026#34;);\rchar input;\rif (scanf(\u0026#34;%c\u0026#34;, \u0026amp;input))\r{\rif (input == \u0026#39;v\u0026#39;){\rpthread_t service_verify;\rpthread_create(\u0026amp;service_verify, NULL, SERVICE_VERIFY, NULL);\rpthread_join(service_verify, NULL);\r}\rif (input == \u0026#39;w\u0026#39;){\rpthread_t service_write;\rpthread_create(\u0026amp;service_write, NULL, SERVICE_WRITE, NULL);\rpthread_join(service_write, NULL);\r}\rif (input == \u0026#39;c\u0026#39;){\rpthread_t service_calc;\rpthread_create(\u0026amp;service_calc, NULL, SERVICE_CALC, NULL);\rpthread_join(service_calc, NULL);\r}\r}\r} // end while(1)\rpthread_join(thread_reset, NULL);\r} // end main\r/****************************************************************************************\r* Subroutine to send a string of text to the VGA monitor ****************************************************************************************/\rvoid VGA_text(int x, int y, char * text_ptr)\r{\rvolatile char * character_buffer = (char *) vga_char_ptr ;\t// VGA character buffer\rint offset;\r/* assume that the text string fits on one line */\roffset = (y \u0026lt;\u0026lt; 7) + x;\rwhile ( *(text_ptr) )\r{\r// write to the character buffer\r*(character_buffer + offset) = *(text_ptr);\t++text_ptr;\r++offset;\r}\r}\r/****************************************************************************************\r* Subroutine to clear text to the VGA monitor ****************************************************************************************/\rvoid VGA_text_clear()\r{\rvolatile char * character_buffer = (char *) vga_char_ptr ;\t// VGA character buffer\rint offset, x, y;\rfor (x=0; x\u0026lt;79; x++){\rfor (y=0; y\u0026lt;59; y++){\r/* assume that the text string fits on one line */\roffset = (y \u0026lt;\u0026lt; 7) + x;\r// write to the character buffer\r*(character_buffer + offset) = \u0026#39; \u0026#39;;\t}\r}\r}\r/****************************************************************************************\r* Draw a filled rectangle on the VGA monitor ****************************************************************************************/\r#define SWAP(X,Y) do{int temp=X; X=Y; Y=temp;}while(0) void VGA_box(int x1, int y1, int x2, int y2, short pixel_color)\r{\rchar *pixel_ptr ; int row, col;\r/* check and fix box coordinates to be valid */\rif (x1\u0026gt;639) x1 = 639;\rif (y1\u0026gt;479) y1 = 479;\rif (x2\u0026gt;639) x2 = 639;\rif (y2\u0026gt;479) y2 = 479;\rif (x1\u0026lt;0) x1 = 0;\rif (y1\u0026lt;0) y1 = 0;\rif (x2\u0026lt;0) x2 = 0;\rif (y2\u0026lt;0) y2 = 0;\rif (x1\u0026gt;x2) SWAP(x1,x2);\rif (y1\u0026gt;y2) SWAP(y1,y2);\rfor (row = y1; row \u0026lt;= y2; row++)\rfor (col = x1; col \u0026lt;= x2; ++col)\r{\r//640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\tVGA_PIXEL(col,row,pixel_color);\t}\r}\r/****************************************************************************************\r* Draw a outline rectangle on the VGA monitor ****************************************************************************************/\r#define SWAP(X,Y) do{int temp=X; X=Y; Y=temp;}while(0) void VGA_rect(int x1, int y1, int x2, int y2, short pixel_color)\r{\rchar *pixel_ptr ; int row, col;\r/* check and fix box coordinates to be valid */\rif (x1\u0026gt;639) x1 = 639;\rif (y1\u0026gt;479) y1 = 479;\rif (x2\u0026gt;639) x2 = 639;\rif (y2\u0026gt;479) y2 = 479;\rif (x1\u0026lt;0) x1 = 0;\rif (y1\u0026lt;0) y1 = 0;\rif (x2\u0026lt;0) x2 = 0;\rif (y2\u0026lt;0) y2 = 0;\rif (x1\u0026gt;x2) SWAP(x1,x2);\rif (y1\u0026gt;y2) SWAP(y1,y2);\r// left edge\rcol = x1;\rfor (row = y1; row \u0026lt;= y2; row++){\r//640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\tVGA_PIXEL(col,row,pixel_color);\t}\r// right edge\rcol = x2;\rfor (row = y1; row \u0026lt;= y2; row++){\r//640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\tVGA_PIXEL(col,row,pixel_color);\t}\r// top edge\rrow = y1;\rfor (col = x1; col \u0026lt;= x2; ++col){\r//640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\tVGA_PIXEL(col,row,pixel_color);\r}\r// bottom edge\rrow = y2;\rfor (col = x1; col \u0026lt;= x2; ++col){\r//640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\rVGA_PIXEL(col,row,pixel_color);\r}\r}\r/****************************************************************************************\r* Draw a horixontal line on the VGA monitor ****************************************************************************************/\r#define SWAP(X,Y) do{int temp=X; X=Y; Y=temp;}while(0) void VGA_Hline(int x1, int y1, int x2, short pixel_color)\r{\rchar *pixel_ptr ; int row, col;\r/* check and fix box coordinates to be valid */\rif (x1\u0026gt;639) x1 = 639;\rif (y1\u0026gt;479) y1 = 479;\rif (x2\u0026gt;639) x2 = 639;\rif (x1\u0026lt;0) x1 = 0;\rif (y1\u0026lt;0) y1 = 0;\rif (x2\u0026lt;0) x2 = 0;\rif (x1\u0026gt;x2) SWAP(x1,x2);\r// line\rrow = y1;\rfor (col = x1; col \u0026lt;= x2; ++col){\r//640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\tVGA_PIXEL(col,row,pixel_color);\t}\r}\r/****************************************************************************************\r* Draw a vertical line on the VGA monitor ****************************************************************************************/\r#define SWAP(X,Y) do{int temp=X; X=Y; Y=temp;}while(0) void VGA_Vline(int x1, int y1, int y2, short pixel_color)\r{\rchar *pixel_ptr ; int row, col;\r/* check and fix box coordinates to be valid */\rif (x1\u0026gt;639) x1 = 639;\rif (y1\u0026gt;479) y1 = 479;\rif (y2\u0026gt;479) y2 = 479;\rif (x1\u0026lt;0) x1 = 0;\rif (y1\u0026lt;0) y1 = 0;\rif (y2\u0026lt;0) y2 = 0;\rif (y1\u0026gt;y2) SWAP(y1,y2);\r// line\rcol = x1;\rfor (row = y1; row \u0026lt;= y2; row++){\r//640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\tVGA_PIXEL(col,row,pixel_color);\t}\r}\r/****************************************************************************************\r* Draw a filled circle on the VGA monitor ****************************************************************************************/\rvoid VGA_disc(int x, int y, int r, short pixel_color)\r{\rchar *pixel_ptr ; int row, col, rsqr, xc, yc;\rrsqr = r*r;\rfor (yc = -r; yc \u0026lt;= r; yc++)\rfor (xc = -r; xc \u0026lt;= r; xc++)\r{\rcol = xc;\rrow = yc;\r// add the r to make the edge smoother\rif(col*col+row*row \u0026lt;= rsqr+r){\rcol += x; // add the center point\rrow += y; // add the center point\r//check for valid 640x480\rif (col\u0026gt;639) col = 639;\rif (row\u0026gt;479) row = 479;\rif (col\u0026lt;0) col = 0;\rif (row\u0026lt;0) row = 0;\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\rVGA_PIXEL(col,row,pixel_color);\t}\r}\r}\r/****************************************************************************************\r* Draw a circle on the VGA monitor ****************************************************************************************/\rvoid VGA_circle(int x, int y, int r, int pixel_color)\r{\rchar *pixel_ptr ; int row, col, rsqr, xc, yc;\rint col1, row1;\rrsqr = r*r;\rfor (yc = -r; yc \u0026lt;= r; yc++){\r//row = yc;\rcol1 = (int)sqrt((float)(rsqr + r - yc*yc));\r// right edge\rcol = col1 + x; // add the center point\rrow = yc + y; // add the center point\r//check for valid 640x480\rif (col\u0026gt;639) col = 639;\rif (row\u0026gt;479) row = 479;\rif (col\u0026lt;0) col = 0;\rif (row\u0026lt;0) row = 0;\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\rVGA_PIXEL(col,row,pixel_color);\t// left edge\rcol = -col1 + x; // add the center point\r//check for valid 640x480\rif (col\u0026gt;639) col = 639;\rif (row\u0026gt;479) row = 479;\rif (col\u0026lt;0) col = 0;\rif (row\u0026lt;0) row = 0;\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\rVGA_PIXEL(col,row,pixel_color);\t}\rfor (xc = -r; xc \u0026lt;= r; xc++){\r//row = yc;\rrow1 = (int)sqrt((float)(rsqr + r - xc*xc));\r// right edge\rcol = xc + x; // add the center point\rrow = row1 + y; // add the center point\r//check for valid 640x480\rif (col\u0026gt;639) col = 639;\rif (row\u0026gt;479) row = 479;\rif (col\u0026lt;0) col = 0;\rif (row\u0026lt;0) row = 0;\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\rVGA_PIXEL(col,row,pixel_color);\t// left edge\rrow = -row1 + y; // add the center point\r//check for valid 640x480\rif (col\u0026gt;639) col = 639;\rif (row\u0026gt;479) row = 479;\rif (col\u0026lt;0) col = 0;\rif (row\u0026lt;0) row = 0;\r//pixel_ptr = (char *)vga_pixel_ptr + (row\u0026lt;\u0026lt;10) + col ;\r// set pixel color\r//*(char *)pixel_ptr = pixel_color;\rVGA_PIXEL(col,row,pixel_color);\t}\r}\r// =============================================\r// === Draw a line\r// =============================================\r//plot a line //at x1,y1 to x2,y2 with color //Code is from David Rodgers,\r//\u0026#34;Procedural Elements of Computer Graphics\u0026#34;,1985\rvoid VGA_line(int x1, int y1, int x2, int y2, short c) {\rint e;\rsigned int dx,dy,j, temp;\rsigned int s1,s2, xchange;\rsigned int x,y;\rchar *pixel_ptr ;\r/* check and fix line coordinates to be valid */\rif (x1\u0026gt;639) x1 = 639;\rif (y1\u0026gt;479) y1 = 479;\rif (x2\u0026gt;639) x2 = 639;\rif (y2\u0026gt;479) y2 = 479;\rif (x1\u0026lt;0) x1 = 0;\rif (y1\u0026lt;0) y1 = 0;\rif (x2\u0026lt;0) x2 = 0;\rif (y2\u0026lt;0) y2 = 0;\rx = x1;\ry = y1;\r//take absolute value\rif (x2 \u0026lt; x1) {\rdx = x1 - x2;\rs1 = -1;\r}\relse if (x2 == x1) {\rdx = 0;\rs1 = 0;\r}\relse {\rdx = x2 - x1;\rs1 = 1;\r}\rif (y2 \u0026lt; y1) {\rdy = y1 - y2;\rs2 = -1;\r}\relse if (y2 == y1) {\rdy = 0;\rs2 = 0;\r}\relse {\rdy = y2 - y1;\rs2 = 1;\r}\rxchange = 0; if (dy\u0026gt;dx) {\rtemp = dx;\rdx = dy;\rdy = temp;\rxchange = 1;\r} e = ((int)dy\u0026lt;\u0026lt;1) - dx; for (j=0; j\u0026lt;=dx; j++) {\r//video_pt(x,y,c); //640x480\r//pixel_ptr = (char *)vga_pixel_ptr + (y\u0026lt;\u0026lt;10)+ x; // set pixel color\r//*(char *)pixel_ptr = c;\rVGA_PIXEL(x,y,c);\tif (e\u0026gt;=0) {\rif (xchange==1) x = x + s1;\relse y = y + s2;\re = e - ((int)dx\u0026lt;\u0026lt;1);\r}\rif (xchange==1) y = y + s2;\relse x = x + s1;\re = e + ((int)dy\u0026lt;\u0026lt;1);\r}\r}\r// BOTTOM "},{"id":5,"href":"/docs/appendix/commented-code/verilog-implementation/bresenham/","title":"Bresenham","section":"Verilog Implementation","content":"module bresenham(input logic clk, reset, input logic start, input logic [10:0] x0, y0, x1, y1, input logic enable, output logic plot, output logic [10:0] x, y, output logic done ); logic signed [11:0] dx, dy, err, e2; logic right, down; typedef enum logic [3:0] {IDLE, RUN, DONE} state_t; state_t state; always_ff @(posedge clk) begin done \u0026lt;= 0; plot \u0026lt;= 0; if (reset) state \u0026lt;= IDLE; else case (state) IDLE: if (start) begin dx = x1 - x0; // Blocking! right = dx \u0026gt;= 0; if (~right) dx = -dx; dy = y1 - y0; down = dy \u0026gt;= 0; if (down) dy = -dy; err = dx + dy; x \u0026lt;= x0; y \u0026lt;= y0; plot \u0026lt;= 1; state \u0026lt;= RUN; end RUN: if (x == x1 \u0026amp;\u0026amp; y == y1) begin done \u0026lt;= 1; state \u0026lt;= DONE; end else begin plot \u0026lt;= 1; if (enable) begin e2 = err \u0026lt;\u0026lt; 1; if (e2 \u0026gt; dy) begin err += dy; if (right) x \u0026lt;= x + 10\u0026#39;d 1; else x \u0026lt;= x - 10\u0026#39;d 1; end if (e2 \u0026lt; dx) begin err += dx; if (down) y \u0026lt;= y + 10\u0026#39;d 1; else y \u0026lt;= y - 10\u0026#39;d 1; end end end DONE: begin state \u0026lt;= DONE; done \u0026lt;= 1; end default: state \u0026lt;= IDLE; endcase end endmodule "},{"id":6,"href":"/docs/appendix/commented-code/verilog-implementation/memory-verifier/","title":"Memory Verifier","section":"Verilog Implementation","content":"// ============================================================================ // Module that reads M10k memory back to HPS for testing //============================================================================= module mem_reader( // FPGA ACTING AS PRODUCER input clk, // arm interface input arm_ack, input [19:0] image_mem_data, input reset, output logic fpga_val, output logic fpga_ack, output logic [31:0] fpga_data, output logic [9:0] addr, output logic [9:0] which_mem, output logic done, output logic [31:0] count // for debugging ); assign fpga_data = image_mem_data; logic [3:0] state; assign count = state; always@(posedge clk) begin if (reset) begin addr \u0026lt;= 0; which_mem \u0026lt;= 0; state \u0026lt;= 0; fpga_val \u0026lt;= 0; fpga_ack \u0026lt;= 0; done \u0026lt;= 0; end else if (state == 0) begin // memory latency state \u0026lt;= 1; end else if (state == 1) begin state \u0026lt;= 2; fpga_val \u0026lt;= 1; end else if (state == 2) begin // wait for arm ack state \u0026lt;= 2; if (arm_ack) begin //if got ack, go to next state state \u0026lt;= 3; fpga_val \u0026lt;= 0; // deassert val fpga_ack \u0026lt;= 1; end end else if (state == 3) begin // wait for arm to deassert ack state \u0026lt;= 3; if(~arm_ack) begin // if arm deasserted ack, go to next state state \u0026lt;= 4; fpga_ack \u0026lt;= 0; end end else if (state == 4) begin addr \u0026lt;= addr + 1; state \u0026lt;= 0; // count \u0026lt;= count + 1; if (addr == 479) begin addr \u0026lt;= 0; which_mem \u0026lt;= which_mem + 1; if (which_mem == 239) begin done \u0026lt;= 1; state \u0026lt;= 5; end end end end endmodule "},{"id":7,"href":"/docs/appendix/commented-code/verilog-implementation/memory-writer/","title":"Memory Writer","section":"Verilog Implementation","content":"// ============================================================================ // Module that writes to M10k memory using data from HPS //============================================================================= module mem_writer( input clk, // arm interface input [31:0] arm_data, input arm_val, input arm_ack, input reset, // fpga interface output logic fpga_ack, // for memories output signed [19:0] d, output logic [9:0] addr, output logic we, output logic [9:0] which_mem, output logic done, // for debug output logic [31:0] count // for debugging ); // assign which_mem = arm_data[31:16]; logic is_last; logic [3:0] state; assign state_debug = state; assign d = arm_data; assign count = state; always@(posedge clk) begin if (reset) begin done \u0026lt;= 0; fpga_ack \u0026lt;= 0; addr \u0026lt;= 0; which_mem \u0026lt;= 0; state \u0026lt;= 0; // count \u0026lt;= 0; end else if (state == 0) begin state \u0026lt;= 0; if (arm_val) begin // have a valid request we \u0026lt;= 1; state \u0026lt;= 1; is_last \u0026lt;= arm_data[31]; fpga_ack \u0026lt;= 1; // ack the request end end else if (state == 1) begin state \u0026lt;= 1; // stay in this state until we get a clear ack if (arm_ack) begin state \u0026lt;= 2; // increment state fpga_ack \u0026lt;= 0; // clear ack end end else if (state == 2) begin state \u0026lt;= 2; // stay in this state until we get a clear ack if ( ~arm_ack) begin state \u0026lt;= 3; end end else if (state == 3) begin addr \u0026lt;= addr + 1; // count \u0026lt;= count + 1; if (addr == 479) begin addr \u0026lt;= 0; which_mem \u0026lt;= which_mem + 1; end if ( is_last ) begin done \u0026lt;= 1; state \u0026lt;= 4; end else begin state \u0026lt;= 0; end end end endmodule "},{"id":8,"href":"/docs/appendix/commented-code/verilog-implementation/solvers/","title":"Solvers","section":"Verilog Implementation","content":"module solvers( input clk, reset, input arm_val, input arm_ack, input [31:0] arm_data, input [31:0] arm_data2, input [19:0] image_mem_data, // 239 image mems output logic fpga_val, output logic fpga_ack, output logic [31:0] fpga_data, output logic [9:0] image_mem_addr, output logic [9:0] which_mem, output logic we, output logic [19:0] image_mem_writeout, output logic [31:0] debug_count ); logic [8:0] x0, y0; logic [8:0] x1s [0:39]; logic [8:0] y1s [0:39]; logic [8:0] xs [0:39]; logic [8:0] ys [0:39]; logic [39:0] valids; logic [39:0] dones; logic combined_dones; assign combined_dones = \u0026amp;dones; logic [39:0] enable_bs; // logic signed [7:0] with [0:89]; // logic signed [7:0] without [0:89]; logic [15:0] total_norms [0:39]; logic signed [15:0] total_reductions [0:39]; logic signed [15:0] reductions [0:39]; logic signed [8:0] image_readouts [0:39]; always_comb begin integer ir; for (ir=0;ir\u0026lt;40; ir=ir+1) begin: image_readouts_comb if (ys[ir][0]) begin image_readouts[ir] = image_mem_data[8:0]; end else begin image_readouts[ir] = image_mem_data[17:9]; end end end logic br_reset; genvar i; generate for (i=0; i\u0026lt;40; i=i+1) begin: imageMemGen bresenham br( .clk(clk), .reset(br_reset), .start(\u0026#39;1), .x0(x0), .y0(y0), .x1(x1s[i]), .y1(y1s[i]), .enable(enable_bs[i]), .x(xs[i]), .y(ys[i]), .plot(valids[i]), .done(dones[i]) ); end endgenerate genvar j; generate for (j=0; j\u0026lt;40; j=j+1) begin: reductionGen reduction_calculator rc( .image_data(image_readouts[j]), .weight_data(0), .reduction(reductions[j]) ); end endgenerate // logic [9:0] image_mem_data_idx [0:39]; // variable to keep track of where we should be reading from logic [7:0] state; logic [7:0] read_index; logic [7:0] read_counter; // logic all_last; logic group_last; logic group_first; logic is_last; logic have_valid; integer rr, ii, jj, rrr, kk, iii, lll, ccc, jjj; logic [9:0] wants [0:479]; assign debug_count[5:0] = state; assign debug_count[31:24] = read_counter; logic [10:0] want; logic [39:0] hit; logic direction; logic hit_reduction; assign hit_reduction = |hit; always @(posedge clk) begin if (reset) begin debug_count[7] \u0026lt;= \u0026#39;0; debug_count[6] \u0026lt;= 0; we \u0026lt;= 0; which_mem \u0026lt;= 0; state \u0026lt;= 0; read_index \u0026lt;= 0; group_first \u0026lt;= 1; want \u0026lt;= 0; hit \u0026lt;= 0; fpga_val \u0026lt;= 0; fpga_ack \u0026lt;= 0; read_counter \u0026lt;= 0; // generate: for (rr=0; rr\u0026lt;40; rr=rr+1) begin : reset_loop total_reductions[rr] \u0026lt;= 0; total_norms[rr] \u0026lt;= 0; enable_bs[rr] \u0026lt;= 0; end // endgenerate end else if (state == 0) begin // wait asynch read of endpoint data from arm state \u0026lt;= 0; if (arm_val) begin state \u0026lt;= 1; fpga_ack \u0026lt;= 1; // all_last \u0026lt;= arm_data[31]; group_last \u0026lt;= arm_data[31]; group_first \u0026lt;= 0; if (group_first) begin x0 \u0026lt;= arm_data[8:0]; y0 \u0026lt;= arm_data[17:9]; end else begin // if (arm_data[8:0] \u0026lt; want) begin // direction \u0026lt;= 1; // end // else begin // direction \u0026lt;= 0; // end x1s[read_index] \u0026lt;= arm_data[8:0]; y1s[read_index] \u0026lt;= arm_data[17:9]; read_index \u0026lt;= read_index + 1; end end end // 2 HANDSHAKE ================================================ else if (state == 1) begin state \u0026lt;= 1; if (arm_ack) begin state \u0026lt;= 2; fpga_ack \u0026lt;= 0; end end else if (state == 2) begin state \u0026lt;= 2; if (~arm_ack) begin state \u0026lt;= 3; end end // 2 HANDSHAKE ================================================ else if (state == 3) begin if ( group_last ) begin state \u0026lt;= 4; br_reset \u0026lt;= 1; for (ii=0; ii\u0026lt;40; ii=ii+1) begin enable_bs[ii] \u0026lt;= 0; // disable all bresenhams end end else begin state \u0026lt;= 0; end end else if (state == 4) begin // RESET THE BRESENHAM SOLVERS, START COMPUTATIONS br_reset \u0026lt;= 0; //drop out of reset state \u0026lt;= 5; end else if (state == 5) begin // br_reset \u0026lt;= 0; state \u0026lt;= 6; end else if (state == 6) begin // BRESENHAM SOLVERS RUNNING state \u0026lt;= 7; image_mem_addr \u0026lt;= xs[want]; for (lll=0; lll\u0026lt;40; lll=lll+1) begin wants[ys[lll]] \u0026lt;= xs[lll]; end which_mem \u0026lt;= ys[want] \u0026gt;\u0026gt; 1; if (combined_dones) begin state \u0026lt;= 10; end // if (dones[want]) begin // state \u0026lt;= 6; // want \u0026lt;= want + 1; // if (want == 39) begin // state \u0026lt;= 10; // end // end end else if (state == 7) begin // memory latency state \u0026lt;= 8; for (ccc=0; ccc\u0026lt;40; ccc=ccc+1) begin if (wants[ys[ccc]] == xs[ccc]) begin enable_bs[ccc] \u0026lt;= 1; end else begin enable_bs[ccc] \u0026lt;= 0; end end // ack_bs \u0026lt;= 0; end else if (state == 8) begin // memory latency state \u0026lt;= 9; for (jjj=0; jjj\u0026lt;40; jjj=jjj+1) begin enable_bs[jjj] \u0026lt;= 0; end // enable_bs[want] \u0026lt;= 1; // enable just want end else if (state == 9) begin // this cycle bs_enable is 1, next cycle we will have next valid state \u0026lt;= 6; enable_bs[want] \u0026lt;= 0; // disable just want total_norms[want] \u0026lt;= total_norms[want] + 1; total_reductions[want] \u0026lt;= total_reductions[want] + reductions[want]; end else if (state == 10) begin // nothing was valid, send values to arm state \u0026lt;= 11; fpga_val \u0026lt;= 1; fpga_ack \u0026lt;= 0; fpga_data \u0026lt;= {total_norms[read_counter], total_reductions[read_counter]}; end else if (state == 11) begin state \u0026lt;= 11; if (arm_ack) begin state \u0026lt;= 12; fpga_val \u0026lt;= 0; fpga_ack \u0026lt;= 1; end end else if (state == 12) begin state \u0026lt;= 12; if (~arm_ack) begin state \u0026lt;= 13; fpga_ack \u0026lt;= 0; end end else if (state == 13) begin read_counter \u0026lt;= read_counter + 1; state \u0026lt;= 10; if (read_counter == 39) begin // done writing everything to arm debug_count[6] \u0026lt;= 1; state \u0026lt;= 14; end end else if (state == 14) begin // read write requests from arm state \u0026lt;= 14; if (arm_val) begin we \u0026lt;= 1; image_mem_writeout \u0026lt;= arm_data[19:0]; image_mem_addr \u0026lt;= arm_data2[15:0]; which_mem \u0026lt;= arm_data2[31:16]; state \u0026lt;= 15; is_last \u0026lt;= arm_data[31]; fpga_ack \u0026lt;= 1; end end else if (state == 15) begin state \u0026lt;= 15; if (arm_ack) begin state \u0026lt;= 16; fpga_ack \u0026lt;= 0; end end else if (state == 16) begin state \u0026lt;= 16; if (~arm_ack) begin state \u0026lt;= 17; end end else if (state == 17) begin if ( is_last ) begin debug_count[7] \u0026lt;= \u0026#39;1; fpga_val \u0026lt;= 0; fpga_ack \u0026lt;= 0; we \u0026lt;= 0; which_mem \u0026lt;= 0; state \u0026lt;= 0; read_index \u0026lt;= 0; group_first \u0026lt;= 1; want \u0026lt;= 0; hit \u0026lt;= 0; read_counter \u0026lt;= 0; for (rrr=0; rrr\u0026lt;40; rrr=rrr+1) begin total_reductions[rrr] \u0026lt;= 0; total_norms[rrr] \u0026lt;= 0; end end else begin state \u0026lt;= 14; end end end endmodule "},{"id":9,"href":"/docs/appendix/commented-code/verilog-implementation/top-level/","title":"Top Level","section":"Verilog Implementation","content":" module DE1_SoC_Computer ( //////////////////////////////////// // FPGA Pins //////////////////////////////////// // Clock pins CLOCK_50, CLOCK2_50, CLOCK3_50, CLOCK4_50, // ADC ADC_CS_N, ADC_DIN, ADC_DOUT, ADC_SCLK, // Audio AUD_ADCDAT, AUD_ADCLRCK, AUD_BCLK, AUD_DACDAT, AUD_DACLRCK, AUD_XCK, // SDRAM DRAM_ADDR, DRAM_BA, DRAM_CAS_N, DRAM_CKE, DRAM_CLK, DRAM_CS_N, DRAM_DQ, DRAM_LDQM, DRAM_RAS_N, DRAM_UDQM, DRAM_WE_N, // I2C Bus for Configuration of the Audio and Video-In Chips FPGA_I2C_SCLK, FPGA_I2C_SDAT, // 40-Pin Headers GPIO_0, GPIO_1, // Seven Segment Displays HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, // IR IRDA_RXD, IRDA_TXD, // Pushbuttons KEY, // LEDs LEDR, // PS2 Ports PS2_CLK, PS2_DAT, PS2_CLK2, PS2_DAT2, // Slider Switches SW, // Video-In TD_CLK27, TD_DATA, TD_HS, TD_RESET_N, TD_VS, // VGA VGA_B, VGA_BLANK_N, VGA_CLK, VGA_G, VGA_HS, VGA_R, VGA_SYNC_N, VGA_VS, //////////////////////////////////// // HPS Pins //////////////////////////////////// // DDR3 SDRAM HPS_DDR3_ADDR, HPS_DDR3_BA, HPS_DDR3_CAS_N, HPS_DDR3_CKE, HPS_DDR3_CK_N, HPS_DDR3_CK_P, HPS_DDR3_CS_N, HPS_DDR3_DM, HPS_DDR3_DQ, HPS_DDR3_DQS_N, HPS_DDR3_DQS_P, HPS_DDR3_ODT, HPS_DDR3_RAS_N, HPS_DDR3_RESET_N, HPS_DDR3_RZQ, HPS_DDR3_WE_N, // Ethernet HPS_ENET_GTX_CLK, HPS_ENET_INT_N, HPS_ENET_MDC, HPS_ENET_MDIO, HPS_ENET_RX_CLK, HPS_ENET_RX_DATA, HPS_ENET_RX_DV, HPS_ENET_TX_DATA, HPS_ENET_TX_EN, // Flash HPS_FLASH_DATA, HPS_FLASH_DCLK, HPS_FLASH_NCSO, // Accelerometer HPS_GSENSOR_INT, // General Purpose I/O HPS_GPIO, // I2C HPS_I2C_CONTROL, HPS_I2C1_SCLK, HPS_I2C1_SDAT, HPS_I2C2_SCLK, HPS_I2C2_SDAT, // Pushbutton HPS_KEY, // LED HPS_LED, // SD Card HPS_SD_CLK, HPS_SD_CMD, HPS_SD_DATA, // SPI HPS_SPIM_CLK, HPS_SPIM_MISO, HPS_SPIM_MOSI, HPS_SPIM_SS, // UART HPS_UART_RX, HPS_UART_TX, // USB HPS_CONV_USB_N, HPS_USB_CLKOUT, HPS_USB_DATA, HPS_USB_DIR, HPS_USB_NXT, HPS_USB_STP ); //======================================================= // PARAMETER declarations //======================================================= //======================================================= // PORT declarations //======================================================= //////////////////////////////////// // FPGA Pins //////////////////////////////////// // Clock pins input CLOCK_50; input CLOCK2_50; input CLOCK3_50; input CLOCK4_50; // ADC inout ADC_CS_N; output ADC_DIN; input ADC_DOUT; output ADC_SCLK; // Audio input AUD_ADCDAT; inout AUD_ADCLRCK; inout AUD_BCLK; output AUD_DACDAT; inout AUD_DACLRCK; output AUD_XCK; // SDRAM output [12: 0] DRAM_ADDR; output [ 1: 0] DRAM_BA; output DRAM_CAS_N; output DRAM_CKE; output DRAM_CLK; output DRAM_CS_N; inout [15: 0] DRAM_DQ; output DRAM_LDQM; output DRAM_RAS_N; output DRAM_UDQM; output DRAM_WE_N; // I2C Bus for Configuration of the Audio and Video-In Chips output FPGA_I2C_SCLK; inout FPGA_I2C_SDAT; // 40-pin headers inout [35: 0] GPIO_0; inout [35: 0] GPIO_1; // Seven Segment Displays output [ 6: 0] HEX0; output [ 6: 0] HEX1; output [ 6: 0] HEX2; output [ 6: 0] HEX3; output [ 6: 0] HEX4; output [ 6: 0] HEX5; // IR input IRDA_RXD; output IRDA_TXD; // Pushbuttons input [ 3: 0] KEY; // LEDs output [ 9: 0] LEDR; // PS2 Ports inout PS2_CLK; inout PS2_DAT; inout PS2_CLK2; inout PS2_DAT2; // Slider Switches input [ 9: 0] SW; // Video-In input TD_CLK27; input [ 7: 0] TD_DATA; input TD_HS; output TD_RESET_N; input TD_VS; // VGA output [ 7: 0] VGA_B; output VGA_BLANK_N; output VGA_CLK; output [ 7: 0] VGA_G; output VGA_HS; output [ 7: 0] VGA_R; output VGA_SYNC_N; output VGA_VS; //////////////////////////////////// // HPS Pins //////////////////////////////////// // DDR3 SDRAM output [14: 0] HPS_DDR3_ADDR; output [ 2: 0] HPS_DDR3_BA; output HPS_DDR3_CAS_N; output HPS_DDR3_CKE; output HPS_DDR3_CK_N; output HPS_DDR3_CK_P; output HPS_DDR3_CS_N; output [ 3: 0] HPS_DDR3_DM; inout [31: 0] HPS_DDR3_DQ; inout [ 3: 0] HPS_DDR3_DQS_N; inout [ 3: 0] HPS_DDR3_DQS_P; output HPS_DDR3_ODT; output HPS_DDR3_RAS_N; output HPS_DDR3_RESET_N; input HPS_DDR3_RZQ; output HPS_DDR3_WE_N; // Ethernet output HPS_ENET_GTX_CLK; inout HPS_ENET_INT_N; output HPS_ENET_MDC; inout HPS_ENET_MDIO; input HPS_ENET_RX_CLK; input [ 3: 0] HPS_ENET_RX_DATA; input HPS_ENET_RX_DV; output [ 3: 0] HPS_ENET_TX_DATA; output HPS_ENET_TX_EN; // Flash inout [ 3: 0] HPS_FLASH_DATA; output HPS_FLASH_DCLK; output HPS_FLASH_NCSO; // Accelerometer inout HPS_GSENSOR_INT; // General Purpose I/O inout [ 1: 0] HPS_GPIO; // I2C inout HPS_I2C_CONTROL; inout HPS_I2C1_SCLK; inout HPS_I2C1_SDAT; inout HPS_I2C2_SCLK; inout HPS_I2C2_SDAT; // Pushbutton inout HPS_KEY; // LED inout HPS_LED; // SD Card output HPS_SD_CLK; inout HPS_SD_CMD; inout [ 3: 0] HPS_SD_DATA; // SPI output HPS_SPIM_CLK; input HPS_SPIM_MISO; output HPS_SPIM_MOSI; inout HPS_SPIM_SS; // UART input HPS_UART_RX; output HPS_UART_TX; // USB inout HPS_CONV_USB_N; input HPS_USB_CLKOUT; inout [ 7: 0] HPS_USB_DATA; input HPS_USB_DIR; input HPS_USB_NXT; output HPS_USB_STP; //======================================================= // REG/WIRE declarations //======================================================= wire [15: 0] hex3_hex0; //wire [15: 0] hex5_hex4; //assign HEX0 = ~hex3_hex0[ 6: 0]; // hex3_hex0[ 6: 0]; //assign HEX1 = ~hex3_hex0[14: 8]; //assign HEX2 = ~hex3_hex0[22:16]; //assign HEX3 = ~hex3_hex0[30:24]; assign HEX4 = 7\u0026#39;b1111111; assign HEX5 = 7\u0026#39;b1111111; HexDigit Digit0(HEX0, hex3_hex0[3:0]); HexDigit Digit1(HEX1, hex3_hex0[7:4]); HexDigit Digit2(HEX2, hex3_hex0[11:8]); HexDigit Digit3(HEX3, hex3_hex0[15:12]); // PIO signals wire [31:0] arm_data; // arm output wire [31:0] arm_data2; // arm output wire arm_val; // arm output wire arm_rdy; // arm output wire arm_ack; wire fpga_ack; wire [31:0] fpga_data; // arm input wire fpga_val; // arm input wire fpga_rdy; // arm input // M10k memory clock wire M10k_pll ; wire M10k_pll_locked ; // Instantiate Image memory wire [9:0] image_write_address [0:239]; wire [9:0] image_read_address [0:239]; wire image_we [0:239]; wire [19:0] image_readout [0:239]; wire [19:0] image_writein [0:239]; genvar i; generate for (i=0; i\u0026lt;240; i=i+1) begin: imageMemGen M10K_1000_18 mem( .clk(CLOCK_50), .d(image_writein[i]), .write_address(image_write_address[i]), .read_address(image_read_address[i]), .we(image_we[i]), .q(image_readout[i]) ); end endgenerate // Instantiate Weight memory // wire [9:0] weight_write_address [0:239]; // wire [9:0] weight_read_address [0:239]; // wire weight_we [0:239]; // wire [7:0] weight_readout [0:239]; // wire [7:0] weight_writein [0:239]; // genvar j; // generate // for (j=0; j\u0026lt;240; j=j+1) begin: weightMemGen // M10K_1000_4 mem( // .clk(CLOCK_50), // .d(weight_writein[j]), // .write_address(weight_write_address[j]), // .read_address(weight_read_address[j]), // .we(weight_we[j]), // .q(weight_readout[j]) // ); // end // endgenerate logic mr_fpga_ack, mr_fpga_val, mr_fpga_rdy; logic mw_fpga_ack, mw_fpga_val, mw_fpga_rdy; logic sv_fpga_ack, sv_fpga_val, sv_fpga_rdy; logic [31:0] mr_fpga_data, mw_fpga_data, sv_fpga_data; logic sv_reset; logic [9:0] sv_addr, sv_which; logic sv_we; logic [17:0] sv_image_mem_data, sv_image_mem_writeout; logic [31:0] sv_arm_data; logic [31:0] sv_debug_count; solvers svs ( .clk(CLOCK_50), .reset(sv_reset), .arm_val(arm_val), .arm_ack(arm_ack), .arm_data(arm_data), .arm_data2(arm_data2), .image_mem_data(sv_image_mem_data), .fpga_val(sv_fpga_val), .fpga_ack(sv_fpga_ack), .fpga_data(sv_fpga_data), .image_mem_addr(sv_addr), .which_mem(sv_which), .we(sv_we), .image_mem_writeout(sv_image_mem_writeout), .debug_count(sv_debug_count) ); reg mw_reset; wire mw_done, mw_we; wire [19:0] mw_d; wire [9:0] mw_which_mem; wire [9:0] mw_addr; wire [31:0] mw_count; logic [31:0] mw_arm_data; mem_writer m_w ( .clk(CLOCK_50), .arm_data(arm_data), .arm_val(arm_val), .arm_ack(arm_ack), .reset(mw_reset), .fpga_ack(mw_fpga_ack), .d(mw_d), .addr(mw_addr), .we(mw_we), .which_mem(mw_which_mem), .done(mw_done), .count(mw_count) ); reg mr_reset; wire mr_done; wire [19:0] mr_image_data; wire [9:0] mr_addr; wire [9:0] mr_which_mem; wire [31:0] mr_count; mem_reader m_r ( .clk(CLOCK_50), .arm_ack(arm_ack), .image_mem_data(mr_image_data), .reset(mr_reset), .fpga_val(mr_fpga_val), .fpga_ack(mr_fpga_ack), .fpga_data(mr_fpga_data), .addr(mr_addr), .which_mem(mr_which_mem), .done(mr_done), .count(mr_count) ); assign mr_image_data = image_readout[mr_which_mem]; assign sv_image_mem_data = image_readout[sv_which]; // assign fpga_rdy = mw_fpga_rdy; // assign fpga_val = mr_fpga_val; // assign fpga_data = mr_fpga_data; // assign fpga_rdy = mr_fpga_rdy; // assign fpga_val = mr_fpga_val; // assign fpga_data = mr_fpga_data; assign LEDR[0] = KEY[0] ? 0 : 1; assign LEDR[1] = fpga_ack ? 1 : 0; assign LEDR[2] = sv_fpga_ack ? 1 : 0; assign LEDR[3] = sv_fpga_val ? 1 : 0; assign LEDR[4] = sv_debug_count[7] ? 1 : 0; assign LEDR[5] = sv_debug_count[6] ? 1 : 0; // assign hex3_hex0 = 16\u0026#39;d2; assign pio_reset = ~KEY[0]; reg [3:0] state; assign fpga_rdy = (state \u0026lt; 5 ) ? mw_fpga_rdy : ( (state \u0026gt; 6 ) ? sv_fpga_rdy : mr_fpga_rdy ); assign fpga_val = (state \u0026lt; 5 ) ? mw_fpga_val : ( (state \u0026gt; 6 ) ? sv_fpga_val : mr_fpga_val ); assign fpga_data = (state \u0026lt; 5 ) ? mw_fpga_data : ( (state \u0026gt; 6 ) ? sv_fpga_data : mr_fpga_data ); assign fpga_ack = (state \u0026lt; 5 ) ? mw_fpga_ack : ( (state \u0026gt; 6 ) ? sv_fpga_ack : mr_fpga_ack ); // synthesize 240 comparators genvar k; generate for (k = 0; k \u0026lt; 240; k=k+1) begin : gen_assignments assign image_write_address[k] = (state \u0026gt; 6) ? ( (k == sv_which) ? sv_addr : 0 ) : ( (k == mw_which_mem) ? mw_addr : 0); assign image_writein[k] = (state \u0026gt; 6) ? ( (k == sv_which) ? sv_image_mem_writeout : 0 ) : ( (k == mw_which_mem) ? mw_d : 0); assign image_we[k] = (state \u0026gt; 6) ? ( (k == sv_which) ? sv_we : 0 ) : ( (k == mw_which_mem) ? mw_we : 0 ); assign image_read_address[k] = (state \u0026gt; 6) ? ( (k == sv_which) ? sv_addr : 0) : ( (k == mr_which_mem) ? mr_addr : 0); end endgenerate // assign hex3_hex0 = mr_count; // assign hex3_hex0[3:0] = state; // assign hex3_hex0[7:4] = mw_count[3:0]; // assign hex3_hex0[11:8] = mr_count[3:0]; // assign hex3_hex0[3:0] = sv_debug_count[5:0]; assign hex3_hex0[11:4] = sv_debug_count[31:24]; // assign sv_arm_data = state \u0026gt; 6 ? arm_data : 0; // assign mw_arm_data = state \u0026lt;= 6 ? arm_data : 0; always@(posedge CLOCK_50) begin if (~KEY[0]) begin state \u0026lt;= 0; end else if (state == 0) begin sv_reset \u0026lt;= 1; mw_reset \u0026lt;= 1; mr_reset \u0026lt;= 1; state \u0026lt;= 1; end else if (state == 1) begin mw_reset \u0026lt;= 0; state \u0026lt;= 2; end else if (state == 2) begin state \u0026lt;= 2; if (mw_done == 1) begin state \u0026lt;= 3; end end else if (state == 3) begin //starting the verification state \u0026lt;= 4; end else if (state == 4) begin mr_reset \u0026lt;= 0; state \u0026lt;= 5; end else if (state == 5) begin state \u0026lt;= 5; if (mr_done == 1) begin state \u0026lt;= 6; end end else if (state == 6) begin //starting the solvers mr_reset \u0026lt;= 1; mw_reset \u0026lt;= 1; sv_reset \u0026lt;= 0; state \u0026lt;= 7; end else if (state == 7) begin //let solvers work state \u0026lt;= 7; end end //======================================================= // Structural coding //======================================================= Computer_System The_System ( //////////////////////////////////// // FPGA Side //////////////////////////////////// // PLL .m10k_pll_locked_export (M10k_pll_locked), // m10k_pll_locked.export .m10k_pll_outclk0_clk (M10k_pll), // m10k_pll_outclk0.clk // PIO .arm_data_external_connection_export (arm_data), .arm_data2_external_connection_export (arm_data2), .arm_val_external_connection_export (arm_val), .arm_rdy_external_connection_export (arm_rdy), .arm_ack_external_connection_export (arm_ack), .fpga_data_external_connection_export (fpga_data), .fpga_val_external_connection_export (fpga_val), .fpga_rdy_external_connection_export (fpga_rdy), .pio_reset_external_connection_export (pio_reset), .fpga_ack_external_connection_export (fpga_ack), // Global signals .system_pll_ref_clk_clk (CLOCK_50), .system_pll_ref_reset_reset (1\u0026#39;b0), // AV Config .av_config_SCLK (FPGA_I2C_SCLK), .av_config_SDAT (FPGA_I2C_SDAT), // VGA Subsystem .vga_pll_ref_clk_clk (CLOCK2_50), .vga_pll_ref_reset_reset (1\u0026#39;b0), .vga_CLK (VGA_CLK), .vga_BLANK (VGA_BLANK_N), .vga_SYNC (VGA_SYNC_N), .vga_HS (VGA_HS), .vga_VS (VGA_VS), .vga_R (VGA_R), .vga_G (VGA_G), .vga_B (VGA_B), // SDRAM .sdram_clk_clk (DRAM_CLK), .sdram_addr (DRAM_ADDR), .sdram_ba (DRAM_BA), .sdram_cas_n (DRAM_CAS_N), .sdram_cke (DRAM_CKE), .sdram_cs_n (DRAM_CS_N), .sdram_dq (DRAM_DQ), .sdram_dqm ({DRAM_UDQM,DRAM_LDQM}), .sdram_ras_n (DRAM_RAS_N), .sdram_we_n (DRAM_WE_N), //////////////////////////////////// // HPS Side //////////////////////////////////// // DDR3 SDRAM .memory_mem_a (HPS_DDR3_ADDR), .memory_mem_ba (HPS_DDR3_BA), .memory_mem_ck (HPS_DDR3_CK_P), .memory_mem_ck_n (HPS_DDR3_CK_N), .memory_mem_cke (HPS_DDR3_CKE), .memory_mem_cs_n (HPS_DDR3_CS_N), .memory_mem_ras_n (HPS_DDR3_RAS_N), .memory_mem_cas_n (HPS_DDR3_CAS_N), .memory_mem_we_n (HPS_DDR3_WE_N), .memory_mem_reset_n (HPS_DDR3_RESET_N), .memory_mem_dq (HPS_DDR3_DQ), .memory_mem_dqs (HPS_DDR3_DQS_P), .memory_mem_dqs_n (HPS_DDR3_DQS_N), .memory_mem_odt (HPS_DDR3_ODT), .memory_mem_dm (HPS_DDR3_DM), .memory_oct_rzqin (HPS_DDR3_RZQ), // Ethernet .hps_io_hps_io_gpio_inst_GPIO35 (HPS_ENET_INT_N), .hps_io_hps_io_emac1_inst_TX_CLK (HPS_ENET_GTX_CLK), .hps_io_hps_io_emac1_inst_TXD0 (HPS_ENET_TX_DATA[0]), .hps_io_hps_io_emac1_inst_TXD1 (HPS_ENET_TX_DATA[1]), .hps_io_hps_io_emac1_inst_TXD2 (HPS_ENET_TX_DATA[2]), .hps_io_hps_io_emac1_inst_TXD3 (HPS_ENET_TX_DATA[3]), .hps_io_hps_io_emac1_inst_RXD0 (HPS_ENET_RX_DATA[0]), .hps_io_hps_io_emac1_inst_MDIO (HPS_ENET_MDIO), .hps_io_hps_io_emac1_inst_MDC (HPS_ENET_MDC), .hps_io_hps_io_emac1_inst_RX_CTL (HPS_ENET_RX_DV), .hps_io_hps_io_emac1_inst_TX_CTL (HPS_ENET_TX_EN), .hps_io_hps_io_emac1_inst_RX_CLK (HPS_ENET_RX_CLK), .hps_io_hps_io_emac1_inst_RXD1 (HPS_ENET_RX_DATA[1]), .hps_io_hps_io_emac1_inst_RXD2 (HPS_ENET_RX_DATA[2]), .hps_io_hps_io_emac1_inst_RXD3 (HPS_ENET_RX_DATA[3]), // Flash .hps_io_hps_io_qspi_inst_IO0 (HPS_FLASH_DATA[0]), .hps_io_hps_io_qspi_inst_IO1 (HPS_FLASH_DATA[1]), .hps_io_hps_io_qspi_inst_IO2 (HPS_FLASH_DATA[2]), .hps_io_hps_io_qspi_inst_IO3 (HPS_FLASH_DATA[3]), .hps_io_hps_io_qspi_inst_SS0 (HPS_FLASH_NCSO), .hps_io_hps_io_qspi_inst_CLK (HPS_FLASH_DCLK), // Accelerometer .hps_io_hps_io_gpio_inst_GPIO61 (HPS_GSENSOR_INT), //.adc_sclk (ADC_SCLK), //.adc_cs_n (ADC_CS_N), //.adc_dout (ADC_DOUT), //.adc_din (ADC_DIN), // General Purpose I/O .hps_io_hps_io_gpio_inst_GPIO40 (HPS_GPIO[0]), .hps_io_hps_io_gpio_inst_GPIO41 (HPS_GPIO[1]), // I2C .hps_io_hps_io_gpio_inst_GPIO48 (HPS_I2C_CONTROL), .hps_io_hps_io_i2c0_inst_SDA (HPS_I2C1_SDAT), .hps_io_hps_io_i2c0_inst_SCL (HPS_I2C1_SCLK), .hps_io_hps_io_i2c1_inst_SDA (HPS_I2C2_SDAT), .hps_io_hps_io_i2c1_inst_SCL (HPS_I2C2_SCLK), // Pushbutton .hps_io_hps_io_gpio_inst_GPIO54 (HPS_KEY), // LED .hps_io_hps_io_gpio_inst_GPIO53 (HPS_LED), // SD Card .hps_io_hps_io_sdio_inst_CMD (HPS_SD_CMD), .hps_io_hps_io_sdio_inst_D0 (HPS_SD_DATA[0]), .hps_io_hps_io_sdio_inst_D1 (HPS_SD_DATA[1]), .hps_io_hps_io_sdio_inst_CLK (HPS_SD_CLK), .hps_io_hps_io_sdio_inst_D2 (HPS_SD_DATA[2]), .hps_io_hps_io_sdio_inst_D3 (HPS_SD_DATA[3]), // SPI .hps_io_hps_io_spim1_inst_CLK (HPS_SPIM_CLK), .hps_io_hps_io_spim1_inst_MOSI (HPS_SPIM_MOSI), .hps_io_hps_io_spim1_inst_MISO (HPS_SPIM_MISO), .hps_io_hps_io_spim1_inst_SS0 (HPS_SPIM_SS), // UART .hps_io_hps_io_uart0_inst_RX (HPS_UART_RX), .hps_io_hps_io_uart0_inst_TX (HPS_UART_TX), // USB .hps_io_hps_io_gpio_inst_GPIO09 (HPS_CONV_USB_N), .hps_io_hps_io_usb1_inst_D0 (HPS_USB_DATA[0]), .hps_io_hps_io_usb1_inst_D1 (HPS_USB_DATA[1]), .hps_io_hps_io_usb1_inst_D2 (HPS_USB_DATA[2]), .hps_io_hps_io_usb1_inst_D3 (HPS_USB_DATA[3]), .hps_io_hps_io_usb1_inst_D4 (HPS_USB_DATA[4]), .hps_io_hps_io_usb1_inst_D5 (HPS_USB_DATA[5]), .hps_io_hps_io_usb1_inst_D6 (HPS_USB_DATA[6]), .hps_io_hps_io_usb1_inst_D7 (HPS_USB_DATA[7]), .hps_io_hps_io_usb1_inst_CLK (HPS_USB_CLKOUT), .hps_io_hps_io_usb1_inst_STP (HPS_USB_STP), .hps_io_hps_io_usb1_inst_DIR (HPS_USB_DIR), .hps_io_hps_io_usb1_inst_NXT (HPS_USB_NXT) ); endmodule module M10K_1000_18( output reg [19:0] q, input [19:0] d, input [9:0] write_address, read_address, input we, clk ); // force M10K ram style // 480 words of 18 bits representing 2 rows of 480 pixels, MSB is the second row reg [17:0] mem [479:0] /* synthesis ramstyle = \u0026#34;no_rw_check, M10K\u0026#34; */; always @ (posedge clk) begin if (we) begin mem[write_address] \u0026lt;= d; end q \u0026lt;= mem[read_address]; // q doesn\u0026#39;t get d in this clock cycle end endmodule // module M10K_1000_8( // output reg [7:0] q, // input [7:0] d, // input [9:0] write_address, read_address, // input we, clk // ); // // force M10K ram style // // 960 words of 8 bits representing 2 rows of 480 pixels // reg [7:0] mem [959:0] /* synthesis ramstyle = \u0026#34;no_rw_check, M10K\u0026#34; */; // always @ (posedge clk) begin // if (we) begin // mem[write_address] \u0026lt;= d; // end // q \u0026lt;= mem[read_address]; // q doesn\u0026#39;t get d in this clock cycle // end // endmodule "},{"id":10,"href":"/docs/","title":"Docs","section":"Home","content":""}]